// @generated by protobuf-ts 2.2.2 with parameter generate_dependencies
// @generated from protobuf file "instruments.proto" (package "tinkoff.public.invest.api.contract.v1", syntax proto3)
// tslint:disable
import { ServiceType } from '@protobuf-ts/runtime-rpc';
import type { BinaryWriteOptions } from '@protobuf-ts/runtime';
import type { IBinaryWriter } from '@protobuf-ts/runtime';
import { WireType } from '@protobuf-ts/runtime';
import type { BinaryReadOptions } from '@protobuf-ts/runtime';
import type { IBinaryReader } from '@protobuf-ts/runtime';
import { UnknownFieldHandler } from '@protobuf-ts/runtime';
import type { PartialMessage } from '@protobuf-ts/runtime';
import { reflectionMergePartial } from '@protobuf-ts/runtime';
import { MESSAGE_TYPE } from '@protobuf-ts/runtime';
import { MessageType } from '@protobuf-ts/runtime';
import { SecurityTradingStatus } from './common';
import { MoneyValue } from './common';
import { Quotation } from './common';
import { Timestamp } from './google/protobuf/timestamp';
/**
 * Запрос расписания торгов
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedulesRequest
 */
export interface TradingSchedulesRequest {
    /**
     * @generated from protobuf field: string exchange = 1;
     */
    exchange: string; // Наименование биржи или расчетного календаря. </br>Если не передаётся, возвращается информация по всем доступным торговым площадкам.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало периода по часовому поясу UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание периода по часовому поясу UTC.
}
/**
 * Список торговых площадок
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedulesResponse
 */
export interface TradingSchedulesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.TradingSchedule exchanges = 1;
     */
    exchanges: TradingSchedule[]; // Список торговых площадок и режимов торгов.
}
/**
 * Данные по торговой площадке.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedule
 */
export interface TradingSchedule {
    /**
     * @generated from protobuf field: string exchange = 1;
     */
    exchange: string; // Наименование торговой площадки.
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.TradingDay days = 2;
     */
    days: TradingDay[]; // Массив с торговыми и неторговыми днями.
}
/**
 * Информация о времени торгов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.TradingDay
 */
export interface TradingDay {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 1;
     */
    date?: Timestamp; // Дата.
    /**
     * @generated from protobuf field: bool is_trading_day = 2;
     */
    isTradingDay: boolean; // Признак торгового дня на бирже.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp start_time = 3;
     */
    startTime?: Timestamp; // Время начала торгов по часовому поясу UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp end_time = 4;
     */
    endTime?: Timestamp; // Время окончания торгов по часовому поясу UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp market_order_start_time = 5;
     */
    marketOrderStartTime?: Timestamp; // Время начала подачи заявки по часовому поясу UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp market_order_end_time = 6;
     */
    marketOrderEndTime?: Timestamp; // Время окончания подачи заявки по часовому поясу UTC.
}
/**
 * Запрос получения инструмента по идентификатору.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentRequest
 */
export interface InstrumentRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentIdType id_type = 1;
     */
    idType: InstrumentIdType; // Тип идентификатора инструмента. Возможные значения: figi, ticker. Подробнее об идентификации инструментов: [Идентификация инструментов](https://tinkoff.github.io/investAPI/faq_identification/)
    /**
     * @generated from protobuf field: string class_code = 2;
     */
    classCode: string; // Идентификатор class_code. Обязателен при id_type = ticker.
    /**
     * @generated from protobuf field: string id = 3;
     */
    id: string; // Идентификатор запрашиваемого инструмента.
}
/**
 * Запрос получения инструментов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentsRequest
 */
export interface InstrumentsRequest {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.InstrumentStatus instrument_status = 1;
     */
    instrumentStatus: InstrumentStatus; // Статус запрашиваемых инструментов. Возможные значения: [InstrumentStatus](#instrumentstatus)
}
/**
 * Информация об облигации.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.BondResponse
 */
export interface BondResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Bond instrument = 1;
     */
    instrument?: Bond; // Информация об облигации.
}
/**
 * Список облигаций.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.BondsResponse
 */
export interface BondsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Bond instruments = 1;
     */
    instruments: Bond[]; // Массив облигаций.
}
/**
 * Данные по валюте.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CurrencyResponse
 */
export interface CurrencyResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Currency instrument = 1;
     */
    instrument?: Currency; // Информация о валюте.
}
/**
 * Данные по валютам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.CurrenciesResponse
 */
export interface CurrenciesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Currency instruments = 1;
     */
    instruments: Currency[]; // Массив валют.
}
/**
 * Данные по фонду.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.EtfResponse
 */
export interface EtfResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Etf instrument = 1;
     */
    instrument?: Etf; // Информация о фонде.
}
/**
 * Данные по фондам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.EtfsResponse
 */
export interface EtfsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Etf instruments = 1;
     */
    instruments: Etf[]; // Массив фондов.
}
/**
 * Данные по фьючерсу.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.FutureResponse
 */
export interface FutureResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Future instrument = 1;
     */
    instrument?: Future; // Информация о фьючерсу.
}
/**
 * Данные по фьючерсам.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.FuturesResponse
 */
export interface FuturesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Future instruments = 1;
     */
    instruments: Future[]; // Массив фьючерсов.
}
/**
 * Данные по акции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.ShareResponse
 */
export interface ShareResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Share instrument = 1;
     */
    instrument?: Share; // Информация об акции.
}
/**
 * Данные по акциям.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.SharesResponse
 */
export interface SharesResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Share instruments = 1;
     */
    instruments: Share[]; // Массив акций.
}
/**
 * Объект передачи информации об облигации.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Bond
 */
export interface Bond {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 15;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 16;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: int32 coupon_quantity_per_year = 17;
     */
    couponQuantityPerYear: number; // Количество выплат по купонам в год.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp maturity_date = 18;
     */
    maturityDate?: Timestamp; // Дата погашения облигации в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 19;
     */
    nominal?: MoneyValue; // Номинал облигации.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp state_reg_date = 21;
     */
    stateRegDate?: Timestamp; // Дата выпуска облигации в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp placement_date = 22;
     */
    placementDate?: Timestamp; // Дата размещения в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue placement_price = 23;
     */
    placementPrice?: MoneyValue; // Цена размещения.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue aci_value = 24;
     */
    aciValue?: MoneyValue; // Значение НКД (накопленного купонного дохода) на дату.
    /**
     * @generated from protobuf field: string country_of_risk = 25;
     */
    countryOfRisk: string; // Код страны эмитента.
    /**
     * @generated from protobuf field: string country_of_risk_name = 26;
     */
    countryOfRiskName: string; // Наименование страны эмитента.
    /**
     * @generated from protobuf field: string sector = 27;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: string issue_kind = 28;
     */
    issueKind: string; // Форма выпуска. Возможные значения: </br>**documentary** — документарная; </br>**non_documentary** — бездокументарная.
    /**
     * @generated from protobuf field: int64 issue_size = 29;
     */
    issueSize: bigint; // Размер выпуска.
    /**
     * @generated from protobuf field: int64 issue_size_plan = 30;
     */
    issueSizePlan: bigint; // Плановый размер выпуска.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 31;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 32;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 33;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 34;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: bool floating_coupon_flag = 35;
     */
    floatingCouponFlag: boolean; // Признак облигации с плавающим купоном.
    /**
     * @generated from protobuf field: bool perpetual_flag = 36;
     */
    perpetualFlag: boolean; // Признак бессрочной облигации.
    /**
     * @generated from protobuf field: bool amortization_flag = 37;
     */
    amortizationFlag: boolean; // Признак облигации с амортизацией долга.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 38;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 39;
     */
    apiTradeAvailableFlag: boolean; // Признак доступности торгов через API.
}
/**
 * Объект передачи информации о валюте.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Currency
 */
export interface Currency {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 15;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 16;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 17;
     */
    nominal?: MoneyValue; // Номинал.
    /**
     * @generated from protobuf field: string country_of_risk = 18;
     */
    countryOfRisk: string; // Код страны эмитента.
    /**
     * @generated from protobuf field: string country_of_risk_name = 19;
     */
    countryOfRiskName: string; // Наименование страны эмитента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 20;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 21;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 22;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 23;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: string iso_currency_name = 24;
     */
    isoCurrencyName: string; // Строковый ISO-код валюты.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 25;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 26;
     */
    apiTradeAvailableFlag: boolean; // Признак доступности торгов через API.
}
/**
 * Объект передачи информации об инвестиционном фонде.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Etf
 */
export interface Etf {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 15;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 16;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation fixed_commission = 17;
     */
    fixedCommission?: Quotation; // Размер фиксированной комиссии фонда.
    /**
     * @generated from protobuf field: string focus_type = 18;
     */
    focusType: string; // Возможные значения: </br>**equity** — акции;</br>**fixed_income** — облигации;</br>**mixed_allocation** — смешанный;</br>**money_market** — денежный рынок;</br>**real_estate** — недвижимость;</br>**commodity** — товары;</br>**specialty** — специальный;</br>**private_equity** — private equity;</br>**alternative_investment** — альтернативные инвестиции.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp released_date = 19;
     */
    releasedDate?: Timestamp; // Дата выпуска в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation num_shares = 20;
     */
    numShares?: Quotation; // Количество акций фонда в обращении.
    /**
     * @generated from protobuf field: string country_of_risk = 21;
     */
    countryOfRisk: string; // Код страны эмитента.
    /**
     * @generated from protobuf field: string country_of_risk_name = 22;
     */
    countryOfRiskName: string; // Наименование страны эмитента.
    /**
     * @generated from protobuf field: string sector = 23;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: string rebalancing_freq = 24;
     */
    rebalancingFreq: string; // Частота ребалансировки.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 26;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 27;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 28;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 29;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 30;
     */
    apiTradeAvailableFlag: boolean; // Признак доступности торгов через API.
}
/**
 * Объект передачи информации о фьючерсе.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Future
 */
export interface Future {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: int32 lot = 4;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 5;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 6;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по клиенту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 7;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по клиенту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 8;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 9;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 10;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 11;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 12;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций шорт.
    /**
     * @generated from protobuf field: string name = 13;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 14;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp first_trade_date = 15;
     */
    firstTradeDate?: Timestamp; // Дата начала обращения контракта в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_trade_date = 16;
     */
    lastTradeDate?: Timestamp; // Дата в часовом поясе UTC, до которой возможно проведение операций с фьючерсом.
    /**
     * @generated from protobuf field: string futures_type = 17;
     */
    futuresType: string; // Тип фьючерса. Возможные значения: </br>**physical_delivery** — физические поставки; </br>**cash_settlement** — денежный эквивалент.
    /**
     * @generated from protobuf field: string asset_type = 18;
     */
    assetType: string; // Тип актива. Возможные значения: </br>**commodity** — товар; </br>**currency** — валюта; </br>**security** — ценная бумага; </br>**index** — индекс.
    /**
     * @generated from protobuf field: string basic_asset = 19;
     */
    basicAsset: string; // Основной актив.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size = 20;
     */
    basicAssetSize?: Quotation; // Размер основного актива.
    /**
     * @generated from protobuf field: string country_of_risk = 21;
     */
    countryOfRisk: string; // Код страны эмитента.
    /**
     * @generated from protobuf field: string country_of_risk_name = 22;
     */
    countryOfRiskName: string; // Наименование страны эмитента.
    /**
     * @generated from protobuf field: string sector = 23;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp expiration_date = 24;
     */
    expirationDate?: Timestamp; // Дата истечения срока в часов поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 26;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 27;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 28;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 29;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 30;
     */
    apiTradeAvailableFlag: boolean; // Признак доступности торгов через API.
}
/**
 * Объект передачи информации об акции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Share
 */
export interface Share {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код (секция торгов).
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 15;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 16;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp ipo_date = 17;
     */
    ipoDate?: Timestamp; // Дата IPO акции в часовом поясе UTC.
    /**
     * @generated from protobuf field: int64 issue_size = 18;
     */
    issueSize: bigint; // Размер выпуска.
    /**
     * @generated from protobuf field: string country_of_risk = 19;
     */
    countryOfRisk: string; // Код страны эмитента.
    /**
     * @generated from protobuf field: string country_of_risk_name = 20;
     */
    countryOfRiskName: string; // Наименование страны эмитента.
    /**
     * @generated from protobuf field: string sector = 21;
     */
    sector: string; // Сектор экономики.
    /**
     * @generated from protobuf field: int64 issue_size_plan = 22;
     */
    issueSizePlan: bigint; // Плановый размер выпуска.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 23;
     */
    nominal?: MoneyValue; // Номинал.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 26;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 27;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 28;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: bool div_yield_flag = 29;
     */
    divYieldFlag: boolean; // Признак наличия дивидендной доходности.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.ShareType share_type = 30;
     */
    shareType: ShareType; // Тип акции. Возможные значения: [ShareType](https://tinkoff.github.io/investAPI/instruments#sharetype)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 31;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 32;
     */
    apiTradeAvailableFlag: boolean; // Признак доступности торгов через API.
}
/**
 * Запрос НКД по облигации
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetAccruedInterestsRequest
 */
export interface GetAccruedInterestsRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало запрашиваемого периода в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание запрашиваемого периода в часовом поясе UTC.
}
/**
 * НКД облигации
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetAccruedInterestsResponse
 */
export interface GetAccruedInterestsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.AccruedInterest accrued_interests = 1;
     */
    accruedInterests: AccruedInterest[]; // Массив операций начисления купонов.
}
/**
 * Операция начисления купонов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.AccruedInterest
 */
export interface AccruedInterest {
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 1;
     */
    date?: Timestamp; // Дата и время выплаты в часовом поясе UTC.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation value = 2;
     */
    value?: Quotation; // Величина выплаты.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation value_percent = 3;
     */
    valuePercent?: Quotation; // Величина выплаты в процентах от номинала.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation nominal = 4;
     */
    nominal?: Quotation; // Номинал облигации.
}
/**
 * Запрос информации о фьючерсе
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetFuturesMarginRequest
 */
export interface GetFuturesMarginRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Идентификатор инструмента.
}
/**
 * Данные по фьючерсу
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetFuturesMarginResponse
 */
export interface GetFuturesMarginResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_buy = 1;
     */
    initialMarginOnBuy?: MoneyValue; // Гарантийное обеспечение при покупке.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_sell = 2;
     */
    initialMarginOnSell?: MoneyValue; // Гарантийное обеспечение при продаже.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 3;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment_amount = 4;
     */
    minPriceIncrementAmount?: Quotation; // Стоимость шага цены.
}
/**
 * Данные по инструменту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.InstrumentResponse
 */
export interface InstrumentResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Instrument instrument = 1;
     */
    instrument?: Instrument; // Основная информация об инструменте.
}
/**
 * Объект передачи основной информации об инструменте.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Instrument
 */
export interface Instrument {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: string ticker = 2;
     */
    ticker: string; // Тикер инструмента.
    /**
     * @generated from protobuf field: string class_code = 3;
     */
    classCode: string; // Класс-код инструмента.
    /**
     * @generated from protobuf field: string isin = 4;
     */
    isin: string; // Isin-идентификатор инструмента.
    /**
     * @generated from protobuf field: int32 lot = 5;
     */
    lot: number; // Лотность инструмента. Возможно совершение операций только на количества ценной бумаги, кратные параметру *lot*. Подробнее: [лот](https://tinkoff.github.io/investAPI/glossary#lot)
    /**
     * @generated from protobuf field: string currency = 6;
     */
    currency: string; // Валюта расчётов.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation klong = 7;
     */
    klong?: Quotation; // Коэффициент ставки риска длинной позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation kshort = 8;
     */
    kshort?: Quotation; // Коэффициент ставки риска короткой позиции по инструменту.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong = 9;
     */
    dlong?: Quotation; // Ставка риска минимальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort = 10;
     */
    dshort?: Quotation; // Ставка риска минимальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11;
     */
    dlongMin?: Quotation; // Ставка риска начальной маржи в лонг. Подробнее: [ставка риска в лонг](https://help.tinkoff.ru/margin-trade/long/risk-rate/)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12;
     */
    dshortMin?: Quotation; // Ставка риска начальной маржи в шорт. Подробнее: [ставка риска в шорт](https://help.tinkoff.ru/margin-trade/short/risk-rate/)
    /**
     * @generated from protobuf field: bool short_enabled_flag = 13;
     */
    shortEnabledFlag: boolean; // Признак доступности для операций в шорт.
    /**
     * @generated from protobuf field: string name = 14;
     */
    name: string; // Название инструмента.
    /**
     * @generated from protobuf field: string exchange = 15;
     */
    exchange: string; // Торговая площадка.
    /**
     * @generated from protobuf field: string country_of_risk = 16;
     */
    countryOfRisk: string; // Код страны эмитента.
    /**
     * @generated from protobuf field: string country_of_risk_name = 17;
     */
    countryOfRiskName: string; // Наименование страны эмитента.
    /**
     * @generated from protobuf field: string instrument_type = 18;
     */
    instrumentType: string; // Тип инструмента.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 19;
     */
    tradingStatus: SecurityTradingStatus; // Текущий режим торгов инструмента.
    /**
     * @generated from protobuf field: bool otc_flag = 20;
     */
    otcFlag: boolean; // Признак внебиржевой ценной бумаги.
    /**
     * @generated from protobuf field: bool buy_available_flag = 21;
     */
    buyAvailableFlag: boolean; // Признак доступности для покупки.
    /**
     * @generated from protobuf field: bool sell_available_flag = 22;
     */
    sellAvailableFlag: boolean; // Признак доступности для продажи.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 23;
     */
    minPriceIncrement?: Quotation; // Шаг цены.
    /**
     * @generated from protobuf field: bool api_trade_available_flag = 24;
     */
    apiTradeAvailableFlag: boolean; // Признак доступности торгов через API.
}
/**
 * Запрос дивидендов.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsRequest
 */
export interface GetDividendsRequest {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор инструмента.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало запрашиваемого периода в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание запрашиваемого периода в часовом поясе UTC.
}
/**
 * Дивиденды.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsResponse
 */
export interface GetDividendsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Dividend dividends = 1;
     */
    dividends: Dividend[];
}
/**
 * Информация о выплате.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Dividend
 */
export interface Dividend {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue dividend_net = 1;
     */
    dividendNet?: MoneyValue; // Величина дивиденда на 1 ценную бумагу (включая валюту).
    /**
     * @generated from protobuf field: google.protobuf.Timestamp payment_date = 2;
     */
    paymentDate?: Timestamp; // Дата фактических выплат в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp declared_date = 3;
     */
    declaredDate?: Timestamp; // Дата объявления дивидендов в часовом поясе UTC.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp last_buy_date = 4;
     */
    lastBuyDate?: Timestamp; // Последний день (включительно) покупки для получения выплаты в часовом поясе UTC.
    /**
     * @generated from protobuf field: string dividend_type = 5;
     */
    dividendType: string; // Тип выплаты. Возможные значения: Regular Cash – регулярные выплаты, Cancelled – выплата отменена, Daily Accrual – ежедневное начисление, Return of Capital – возврат капитала, прочие типы выплат.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp record_date = 6;
     */
    recordDate?: Timestamp; // Дата фиксации реестра в часовом поясе UTC.
    /**
     * @generated from protobuf field: string regularity = 7;
     */
    regularity: string; // Регулярность выплаты. Возможные значения: Annual – ежегодная, Semi-Anl – каждые полгода, прочие типы выплат.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue close_price = 8;
     */
    closePrice?: MoneyValue; // Цена закрытия инструмента на момент ex_dividend_date.
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation yield_value = 9;
     */
    yieldValue?: Quotation; // Величина доходности.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp created_at = 10;
     */
    createdAt?: Timestamp; // Дата и время создания записи в часовом поясе UTC.
}
/**
 * Тип идентификатора инструмента. Подробнее об идентификации инструментов: [Идентификация инструментов](https://tinkoff.github.io/investAPI/faq_identification/)
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.InstrumentIdType
 */
export enum InstrumentIdType {
    /**
     * Значение не определено.
     *
     * @generated from protobuf enum value: INSTRUMENT_ID_UNSPECIFIED = 0;
     */
    INSTRUMENT_ID_UNSPECIFIED = 0,
    /**
     * Figi.
     *
     * @generated from protobuf enum value: INSTRUMENT_ID_TYPE_FIGI = 1;
     */
    INSTRUMENT_ID_TYPE_FIGI = 1,
    /**
     * Ticker.
     *
     * @generated from protobuf enum value: INSTRUMENT_ID_TYPE_TICKER = 2;
     */
    INSTRUMENT_ID_TYPE_TICKER = 2
}
/**
 * Статус запрашиваемых инструментов.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.InstrumentStatus
 */
export enum InstrumentStatus {
    /**
     * Значение не определено.
     *
     * @generated from protobuf enum value: INSTRUMENT_STATUS_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Базовый список инструментов (по умолчанию). Инструменты доступные для торговли через TINKOFF INVEST API.
     *
     * @generated from protobuf enum value: INSTRUMENT_STATUS_BASE = 1;
     */
    BASE = 1,
    /**
     * Список всех инструментов.
     *
     * @generated from protobuf enum value: INSTRUMENT_STATUS_ALL = 2;
     */
    ALL = 2
}
/**
 * Тип акций.
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.ShareType
 */
export enum ShareType {
    /**
     * Значение не определено.
     *
     * @generated from protobuf enum value: SHARE_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Обыкновенная
     *
     * @generated from protobuf enum value: SHARE_TYPE_COMMON = 1;
     */
    COMMON = 1,
    /**
     * Привилегированная
     *
     * @generated from protobuf enum value: SHARE_TYPE_PREFERRED = 2;
     */
    PREFERRED = 2,
    /**
     * Американские депозитарные расписки
     *
     * @generated from protobuf enum value: SHARE_TYPE_ADR = 3;
     */
    ADR = 3,
    /**
     * Глобальные депозитарные расписки
     *
     * @generated from protobuf enum value: SHARE_TYPE_GDR = 4;
     */
    GDR = 4,
    /**
     * Товарищество с ограниченной ответственностью
     *
     * @generated from protobuf enum value: SHARE_TYPE_MLP = 5;
     */
    MLP = 5,
    /**
     * Акции из реестра Нью-Йорка
     *
     * @generated from protobuf enum value: SHARE_TYPE_NY_REG_SHRS = 6;
     */
    NY_REG_SHRS = 6,
    /**
     * Закрытый инвестиционный фонд
     *
     * @generated from protobuf enum value: SHARE_TYPE_CLOSED_END_FUND = 7;
     */
    CLOSED_END_FUND = 7,
    /**
     * Траст недвижимости
     *
     * @generated from protobuf enum value: SHARE_TYPE_REIT = 8;
     */
    REIT = 8
}
// @generated message type with reflection information, may provide speed optimized methods
class TradingSchedulesRequest$Type extends MessageType<TradingSchedulesRequest> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.TradingSchedulesRequest', [
			{ no: 1, name: 'exchange', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'from', kind: 'message', T: () => Timestamp },
			{ no: 3, name: 'to', kind: 'message', T: () => Timestamp }
		]);
	}
	create(value?: PartialMessage<TradingSchedulesRequest>): TradingSchedulesRequest {
		const message = { exchange: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<TradingSchedulesRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingSchedulesRequest): TradingSchedulesRequest {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string exchange */ 1:
				message.exchange = reader.string();
				break;
			case /* google.protobuf.Timestamp from */ 2:
				message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
				break;
			case /* google.protobuf.Timestamp to */ 3:
				message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: TradingSchedulesRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string exchange = 1; */
		if (message.exchange !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.exchange);
		/* google.protobuf.Timestamp from = 2; */
		if (message.from)
			Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp to = 3; */
		if (message.to)
			Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedulesRequest
 */
export const TradingSchedulesRequest = new TradingSchedulesRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingSchedulesResponse$Type extends MessageType<TradingSchedulesResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.TradingSchedulesResponse', [
			{ no: 1, name: 'exchanges', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => TradingSchedule }
		]);
	}
	create(value?: PartialMessage<TradingSchedulesResponse>): TradingSchedulesResponse {
		const message = { exchanges: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<TradingSchedulesResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingSchedulesResponse): TradingSchedulesResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* repeated tinkoff.public.invest.api.contract.v1.TradingSchedule exchanges */ 1:
				message.exchanges.push(TradingSchedule.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: TradingSchedulesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated tinkoff.public.invest.api.contract.v1.TradingSchedule exchanges = 1; */
		for (let i = 0; i < message.exchanges.length; i++)
			TradingSchedule.internalBinaryWrite(message.exchanges[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedulesResponse
 */
export const TradingSchedulesResponse = new TradingSchedulesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingSchedule$Type extends MessageType<TradingSchedule> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.TradingSchedule', [
			{ no: 1, name: 'exchange', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'days', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => TradingDay }
		]);
	}
	create(value?: PartialMessage<TradingSchedule>): TradingSchedule {
		const message = { exchange: '', days: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<TradingSchedule>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingSchedule): TradingSchedule {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string exchange */ 1:
				message.exchange = reader.string();
				break;
			case /* repeated tinkoff.public.invest.api.contract.v1.TradingDay days */ 2:
				message.days.push(TradingDay.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: TradingSchedule, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string exchange = 1; */
		if (message.exchange !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.exchange);
		/* repeated tinkoff.public.invest.api.contract.v1.TradingDay days = 2; */
		for (let i = 0; i < message.days.length; i++)
			TradingDay.internalBinaryWrite(message.days[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingSchedule
 */
export const TradingSchedule = new TradingSchedule$Type();
// @generated message type with reflection information, may provide speed optimized methods
class TradingDay$Type extends MessageType<TradingDay> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.TradingDay', [
			{ no: 1, name: 'date', kind: 'message', T: () => Timestamp },
			{ no: 2, name: 'is_trading_day', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 3, name: 'start_time', kind: 'message', T: () => Timestamp },
			{ no: 4, name: 'end_time', kind: 'message', T: () => Timestamp },
			{ no: 5, name: 'market_order_start_time', kind: 'message', T: () => Timestamp },
			{ no: 6, name: 'market_order_end_time', kind: 'message', T: () => Timestamp }
		]);
	}
	create(value?: PartialMessage<TradingDay>): TradingDay {
		const message = { isTradingDay: false };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<TradingDay>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TradingDay): TradingDay {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* google.protobuf.Timestamp date */ 1:
				message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
				break;
			case /* bool is_trading_day */ 2:
				message.isTradingDay = reader.bool();
				break;
			case /* google.protobuf.Timestamp start_time */ 3:
				message.startTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.startTime);
				break;
			case /* google.protobuf.Timestamp end_time */ 4:
				message.endTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.endTime);
				break;
			case /* google.protobuf.Timestamp market_order_start_time */ 5:
				message.marketOrderStartTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.marketOrderStartTime);
				break;
			case /* google.protobuf.Timestamp market_order_end_time */ 6:
				message.marketOrderEndTime = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.marketOrderEndTime);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: TradingDay, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* google.protobuf.Timestamp date = 1; */
		if (message.date)
			Timestamp.internalBinaryWrite(message.date, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* bool is_trading_day = 2; */
		if (message.isTradingDay !== false)
			writer.tag(2, WireType.Varint).bool(message.isTradingDay);
		/* google.protobuf.Timestamp start_time = 3; */
		if (message.startTime)
			Timestamp.internalBinaryWrite(message.startTime, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp end_time = 4; */
		if (message.endTime)
			Timestamp.internalBinaryWrite(message.endTime, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp market_order_start_time = 5; */
		if (message.marketOrderStartTime)
			Timestamp.internalBinaryWrite(message.marketOrderStartTime, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp market_order_end_time = 6; */
		if (message.marketOrderEndTime)
			Timestamp.internalBinaryWrite(message.marketOrderEndTime, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.TradingDay
 */
export const TradingDay = new TradingDay$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentRequest$Type extends MessageType<InstrumentRequest> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.InstrumentRequest', [
			{ no: 1, name: 'id_type', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.InstrumentIdType', InstrumentIdType] },
			{ no: 2, name: 'class_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'id', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<InstrumentRequest>): InstrumentRequest {
		const message = { idType: 0, classCode: '', id: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<InstrumentRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentRequest): InstrumentRequest {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.InstrumentIdType id_type */ 1:
				message.idType = reader.int32();
				break;
			case /* string class_code */ 2:
				message.classCode = reader.string();
				break;
			case /* string id */ 3:
				message.id = reader.string();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: InstrumentRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.InstrumentIdType id_type = 1; */
		if (message.idType !== 0)
			writer.tag(1, WireType.Varint).int32(message.idType);
		/* string class_code = 2; */
		if (message.classCode !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.classCode);
		/* string id = 3; */
		if (message.id !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.id);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentRequest
 */
export const InstrumentRequest = new InstrumentRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentsRequest$Type extends MessageType<InstrumentsRequest> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.InstrumentsRequest', [
			{ no: 1, name: 'instrument_status', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.InstrumentStatus', InstrumentStatus, 'INSTRUMENT_STATUS_'] }
		]);
	}
	create(value?: PartialMessage<InstrumentsRequest>): InstrumentsRequest {
		const message = { instrumentStatus: 0 };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<InstrumentsRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentsRequest): InstrumentsRequest {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.InstrumentStatus instrument_status */ 1:
				message.instrumentStatus = reader.int32();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: InstrumentsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.InstrumentStatus instrument_status = 1; */
		if (message.instrumentStatus !== 0)
			writer.tag(1, WireType.Varint).int32(message.instrumentStatus);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentsRequest
 */
export const InstrumentsRequest = new InstrumentsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BondResponse$Type extends MessageType<BondResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.BondResponse', [
			{ no: 1, name: 'instrument', kind: 'message', T: () => Bond }
		]);
	}
	create(value?: PartialMessage<BondResponse>): BondResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<BondResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BondResponse): BondResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.Bond instrument */ 1:
				message.instrument = Bond.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: BondResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.Bond instrument = 1; */
		if (message.instrument)
			Bond.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.BondResponse
 */
export const BondResponse = new BondResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class BondsResponse$Type extends MessageType<BondsResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.BondsResponse', [
			{ no: 1, name: 'instruments', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Bond }
		]);
	}
	create(value?: PartialMessage<BondsResponse>): BondsResponse {
		const message = { instruments: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<BondsResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: BondsResponse): BondsResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* repeated tinkoff.public.invest.api.contract.v1.Bond instruments */ 1:
				message.instruments.push(Bond.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: BondsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated tinkoff.public.invest.api.contract.v1.Bond instruments = 1; */
		for (let i = 0; i < message.instruments.length; i++)
			Bond.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.BondsResponse
 */
export const BondsResponse = new BondsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrencyResponse$Type extends MessageType<CurrencyResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.CurrencyResponse', [
			{ no: 1, name: 'instrument', kind: 'message', T: () => Currency }
		]);
	}
	create(value?: PartialMessage<CurrencyResponse>): CurrencyResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<CurrencyResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrencyResponse): CurrencyResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.Currency instrument */ 1:
				message.instrument = Currency.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CurrencyResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.Currency instrument = 1; */
		if (message.instrument)
			Currency.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CurrencyResponse
 */
export const CurrencyResponse = new CurrencyResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CurrenciesResponse$Type extends MessageType<CurrenciesResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.CurrenciesResponse', [
			{ no: 1, name: 'instruments', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Currency }
		]);
	}
	create(value?: PartialMessage<CurrenciesResponse>): CurrenciesResponse {
		const message = { instruments: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<CurrenciesResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CurrenciesResponse): CurrenciesResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* repeated tinkoff.public.invest.api.contract.v1.Currency instruments */ 1:
				message.instruments.push(Currency.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: CurrenciesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated tinkoff.public.invest.api.contract.v1.Currency instruments = 1; */
		for (let i = 0; i < message.instruments.length; i++)
			Currency.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.CurrenciesResponse
 */
export const CurrenciesResponse = new CurrenciesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EtfResponse$Type extends MessageType<EtfResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.EtfResponse', [
			{ no: 1, name: 'instrument', kind: 'message', T: () => Etf }
		]);
	}
	create(value?: PartialMessage<EtfResponse>): EtfResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<EtfResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EtfResponse): EtfResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.Etf instrument */ 1:
				message.instrument = Etf.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: EtfResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.Etf instrument = 1; */
		if (message.instrument)
			Etf.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.EtfResponse
 */
export const EtfResponse = new EtfResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class EtfsResponse$Type extends MessageType<EtfsResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.EtfsResponse', [
			{ no: 1, name: 'instruments', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Etf }
		]);
	}
	create(value?: PartialMessage<EtfsResponse>): EtfsResponse {
		const message = { instruments: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<EtfsResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: EtfsResponse): EtfsResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* repeated tinkoff.public.invest.api.contract.v1.Etf instruments */ 1:
				message.instruments.push(Etf.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: EtfsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated tinkoff.public.invest.api.contract.v1.Etf instruments = 1; */
		for (let i = 0; i < message.instruments.length; i++)
			Etf.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.EtfsResponse
 */
export const EtfsResponse = new EtfsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FutureResponse$Type extends MessageType<FutureResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.FutureResponse', [
			{ no: 1, name: 'instrument', kind: 'message', T: () => Future }
		]);
	}
	create(value?: PartialMessage<FutureResponse>): FutureResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<FutureResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FutureResponse): FutureResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.Future instrument */ 1:
				message.instrument = Future.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: FutureResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.Future instrument = 1; */
		if (message.instrument)
			Future.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.FutureResponse
 */
export const FutureResponse = new FutureResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FuturesResponse$Type extends MessageType<FuturesResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.FuturesResponse', [
			{ no: 1, name: 'instruments', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Future }
		]);
	}
	create(value?: PartialMessage<FuturesResponse>): FuturesResponse {
		const message = { instruments: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<FuturesResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FuturesResponse): FuturesResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* repeated tinkoff.public.invest.api.contract.v1.Future instruments */ 1:
				message.instruments.push(Future.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: FuturesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated tinkoff.public.invest.api.contract.v1.Future instruments = 1; */
		for (let i = 0; i < message.instruments.length; i++)
			Future.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.FuturesResponse
 */
export const FuturesResponse = new FuturesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ShareResponse$Type extends MessageType<ShareResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.ShareResponse', [
			{ no: 1, name: 'instrument', kind: 'message', T: () => Share }
		]);
	}
	create(value?: PartialMessage<ShareResponse>): ShareResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<ShareResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ShareResponse): ShareResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.Share instrument */ 1:
				message.instrument = Share.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: ShareResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.Share instrument = 1; */
		if (message.instrument)
			Share.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.ShareResponse
 */
export const ShareResponse = new ShareResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SharesResponse$Type extends MessageType<SharesResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.SharesResponse', [
			{ no: 1, name: 'instruments', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Share }
		]);
	}
	create(value?: PartialMessage<SharesResponse>): SharesResponse {
		const message = { instruments: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<SharesResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SharesResponse): SharesResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* repeated tinkoff.public.invest.api.contract.v1.Share instruments */ 1:
				message.instruments.push(Share.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: SharesResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated tinkoff.public.invest.api.contract.v1.Share instruments = 1; */
		for (let i = 0; i < message.instruments.length; i++)
			Share.internalBinaryWrite(message.instruments[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.SharesResponse
 */
export const SharesResponse = new SharesResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Bond$Type extends MessageType<Bond> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.Bond', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'ticker', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'class_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'isin', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 5, name: 'lot', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{ no: 6, name: 'currency', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 7, name: 'klong', kind: 'message', T: () => Quotation },
			{ no: 8, name: 'kshort', kind: 'message', T: () => Quotation },
			{ no: 9, name: 'dlong', kind: 'message', T: () => Quotation },
			{ no: 10, name: 'dshort', kind: 'message', T: () => Quotation },
			{ no: 11, name: 'dlong_min', kind: 'message', T: () => Quotation },
			{ no: 12, name: 'dshort_min', kind: 'message', T: () => Quotation },
			{ no: 13, name: 'short_enabled_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 15, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 16, name: 'exchange', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 17, name: 'coupon_quantity_per_year', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{ no: 18, name: 'maturity_date', kind: 'message', T: () => Timestamp },
			{ no: 19, name: 'nominal', kind: 'message', T: () => MoneyValue },
			{ no: 21, name: 'state_reg_date', kind: 'message', T: () => Timestamp },
			{ no: 22, name: 'placement_date', kind: 'message', T: () => Timestamp },
			{ no: 23, name: 'placement_price', kind: 'message', T: () => MoneyValue },
			{ no: 24, name: 'aci_value', kind: 'message', T: () => MoneyValue },
			{ no: 25, name: 'country_of_risk', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 26, name: 'country_of_risk_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 27, name: 'sector', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 28, name: 'issue_kind', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 29, name: 'issue_size', kind: 'scalar', T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
			{ no: 30, name: 'issue_size_plan', kind: 'scalar', T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
			{ no: 31, name: 'trading_status', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.SecurityTradingStatus', SecurityTradingStatus, 'SECURITY_TRADING_STATUS_'] },
			{ no: 32, name: 'otc_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 33, name: 'buy_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 34, name: 'sell_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 35, name: 'floating_coupon_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 36, name: 'perpetual_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 37, name: 'amortization_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 38, name: 'min_price_increment', kind: 'message', T: () => Quotation },
			{ no: 39, name: 'api_trade_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
		]);
	}
	create(value?: PartialMessage<Bond>): Bond {
		const message = { figi: '', ticker: '', classCode: '', isin: '', lot: 0, currency: '', shortEnabledFlag: false, name: '', exchange: '', couponQuantityPerYear: 0, countryOfRisk: '', countryOfRiskName: '', sector: '', issueKind: '', issueSize: 0n, issueSizePlan: 0n, tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, floatingCouponFlag: false, perpetualFlag: false, amortizationFlag: false, apiTradeAvailableFlag: false };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<Bond>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Bond): Bond {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			case /* string ticker */ 2:
				message.ticker = reader.string();
				break;
			case /* string class_code */ 3:
				message.classCode = reader.string();
				break;
			case /* string isin */ 4:
				message.isin = reader.string();
				break;
			case /* int32 lot */ 5:
				message.lot = reader.int32();
				break;
			case /* string currency */ 6:
				message.currency = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
				message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
				message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
				message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
				message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
				message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
				message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
				break;
			case /* bool short_enabled_flag */ 13:
				message.shortEnabledFlag = reader.bool();
				break;
			case /* string name */ 15:
				message.name = reader.string();
				break;
			case /* string exchange */ 16:
				message.exchange = reader.string();
				break;
			case /* int32 coupon_quantity_per_year */ 17:
				message.couponQuantityPerYear = reader.int32();
				break;
			case /* google.protobuf.Timestamp maturity_date */ 18:
				message.maturityDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.maturityDate);
				break;
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal */ 19:
				message.nominal = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
				break;
			case /* google.protobuf.Timestamp state_reg_date */ 21:
				message.stateRegDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.stateRegDate);
				break;
			case /* google.protobuf.Timestamp placement_date */ 22:
				message.placementDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.placementDate);
				break;
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue placement_price */ 23:
				message.placementPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.placementPrice);
				break;
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue aci_value */ 24:
				message.aciValue = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.aciValue);
				break;
			case /* string country_of_risk */ 25:
				message.countryOfRisk = reader.string();
				break;
			case /* string country_of_risk_name */ 26:
				message.countryOfRiskName = reader.string();
				break;
			case /* string sector */ 27:
				message.sector = reader.string();
				break;
			case /* string issue_kind */ 28:
				message.issueKind = reader.string();
				break;
			case /* int64 issue_size */ 29:
				message.issueSize = reader.int64().toBigInt();
				break;
			case /* int64 issue_size_plan */ 30:
				message.issueSizePlan = reader.int64().toBigInt();
				break;
			case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 31:
				message.tradingStatus = reader.int32();
				break;
			case /* bool otc_flag */ 32:
				message.otcFlag = reader.bool();
				break;
			case /* bool buy_available_flag */ 33:
				message.buyAvailableFlag = reader.bool();
				break;
			case /* bool sell_available_flag */ 34:
				message.sellAvailableFlag = reader.bool();
				break;
			case /* bool floating_coupon_flag */ 35:
				message.floatingCouponFlag = reader.bool();
				break;
			case /* bool perpetual_flag */ 36:
				message.perpetualFlag = reader.bool();
				break;
			case /* bool amortization_flag */ 37:
				message.amortizationFlag = reader.bool();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 38:
				message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
				break;
			case /* bool api_trade_available_flag */ 39:
				message.apiTradeAvailableFlag = reader.bool();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: Bond, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		/* string ticker = 2; */
		if (message.ticker !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.ticker);
		/* string class_code = 3; */
		if (message.classCode !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.classCode);
		/* string isin = 4; */
		if (message.isin !== '')
			writer.tag(4, WireType.LengthDelimited).string(message.isin);
		/* int32 lot = 5; */
		if (message.lot !== 0)
			writer.tag(5, WireType.Varint).int32(message.lot);
		/* string currency = 6; */
		if (message.currency !== '')
			writer.tag(6, WireType.LengthDelimited).string(message.currency);
		/* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
		if (message.klong)
			Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
		if (message.kshort)
			Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
		if (message.dlong)
			Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
		if (message.dshort)
			Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
		if (message.dlongMin)
			Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
		if (message.dshortMin)
			Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
		/* bool short_enabled_flag = 13; */
		if (message.shortEnabledFlag !== false)
			writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
		/* string name = 15; */
		if (message.name !== '')
			writer.tag(15, WireType.LengthDelimited).string(message.name);
		/* string exchange = 16; */
		if (message.exchange !== '')
			writer.tag(16, WireType.LengthDelimited).string(message.exchange);
		/* int32 coupon_quantity_per_year = 17; */
		if (message.couponQuantityPerYear !== 0)
			writer.tag(17, WireType.Varint).int32(message.couponQuantityPerYear);
		/* google.protobuf.Timestamp maturity_date = 18; */
		if (message.maturityDate)
			Timestamp.internalBinaryWrite(message.maturityDate, writer.tag(18, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 19; */
		if (message.nominal)
			MoneyValue.internalBinaryWrite(message.nominal, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp state_reg_date = 21; */
		if (message.stateRegDate)
			Timestamp.internalBinaryWrite(message.stateRegDate, writer.tag(21, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp placement_date = 22; */
		if (message.placementDate)
			Timestamp.internalBinaryWrite(message.placementDate, writer.tag(22, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.MoneyValue placement_price = 23; */
		if (message.placementPrice)
			MoneyValue.internalBinaryWrite(message.placementPrice, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.MoneyValue aci_value = 24; */
		if (message.aciValue)
			MoneyValue.internalBinaryWrite(message.aciValue, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
		/* string country_of_risk = 25; */
		if (message.countryOfRisk !== '')
			writer.tag(25, WireType.LengthDelimited).string(message.countryOfRisk);
		/* string country_of_risk_name = 26; */
		if (message.countryOfRiskName !== '')
			writer.tag(26, WireType.LengthDelimited).string(message.countryOfRiskName);
		/* string sector = 27; */
		if (message.sector !== '')
			writer.tag(27, WireType.LengthDelimited).string(message.sector);
		/* string issue_kind = 28; */
		if (message.issueKind !== '')
			writer.tag(28, WireType.LengthDelimited).string(message.issueKind);
		/* int64 issue_size = 29; */
		if (message.issueSize !== 0n)
			writer.tag(29, WireType.Varint).int64(message.issueSize);
		/* int64 issue_size_plan = 30; */
		if (message.issueSizePlan !== 0n)
			writer.tag(30, WireType.Varint).int64(message.issueSizePlan);
		/* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 31; */
		if (message.tradingStatus !== 0)
			writer.tag(31, WireType.Varint).int32(message.tradingStatus);
		/* bool otc_flag = 32; */
		if (message.otcFlag !== false)
			writer.tag(32, WireType.Varint).bool(message.otcFlag);
		/* bool buy_available_flag = 33; */
		if (message.buyAvailableFlag !== false)
			writer.tag(33, WireType.Varint).bool(message.buyAvailableFlag);
		/* bool sell_available_flag = 34; */
		if (message.sellAvailableFlag !== false)
			writer.tag(34, WireType.Varint).bool(message.sellAvailableFlag);
		/* bool floating_coupon_flag = 35; */
		if (message.floatingCouponFlag !== false)
			writer.tag(35, WireType.Varint).bool(message.floatingCouponFlag);
		/* bool perpetual_flag = 36; */
		if (message.perpetualFlag !== false)
			writer.tag(36, WireType.Varint).bool(message.perpetualFlag);
		/* bool amortization_flag = 37; */
		if (message.amortizationFlag !== false)
			writer.tag(37, WireType.Varint).bool(message.amortizationFlag);
		/* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 38; */
		if (message.minPriceIncrement)
			Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(38, WireType.LengthDelimited).fork(), options).join();
		/* bool api_trade_available_flag = 39; */
		if (message.apiTradeAvailableFlag !== false)
			writer.tag(39, WireType.Varint).bool(message.apiTradeAvailableFlag);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Bond
 */
export const Bond = new Bond$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Currency$Type extends MessageType<Currency> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.Currency', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'ticker', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'class_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'isin', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 5, name: 'lot', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{ no: 6, name: 'currency', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 7, name: 'klong', kind: 'message', T: () => Quotation },
			{ no: 8, name: 'kshort', kind: 'message', T: () => Quotation },
			{ no: 9, name: 'dlong', kind: 'message', T: () => Quotation },
			{ no: 10, name: 'dshort', kind: 'message', T: () => Quotation },
			{ no: 11, name: 'dlong_min', kind: 'message', T: () => Quotation },
			{ no: 12, name: 'dshort_min', kind: 'message', T: () => Quotation },
			{ no: 13, name: 'short_enabled_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 15, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 16, name: 'exchange', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 17, name: 'nominal', kind: 'message', T: () => MoneyValue },
			{ no: 18, name: 'country_of_risk', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 19, name: 'country_of_risk_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 20, name: 'trading_status', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.SecurityTradingStatus', SecurityTradingStatus, 'SECURITY_TRADING_STATUS_'] },
			{ no: 21, name: 'otc_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 22, name: 'buy_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 23, name: 'sell_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 24, name: 'iso_currency_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 25, name: 'min_price_increment', kind: 'message', T: () => Quotation },
			{ no: 26, name: 'api_trade_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
		]);
	}
	create(value?: PartialMessage<Currency>): Currency {
		const message = { figi: '', ticker: '', classCode: '', isin: '', lot: 0, currency: '', shortEnabledFlag: false, name: '', exchange: '', countryOfRisk: '', countryOfRiskName: '', tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, isoCurrencyName: '', apiTradeAvailableFlag: false };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<Currency>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Currency): Currency {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			case /* string ticker */ 2:
				message.ticker = reader.string();
				break;
			case /* string class_code */ 3:
				message.classCode = reader.string();
				break;
			case /* string isin */ 4:
				message.isin = reader.string();
				break;
			case /* int32 lot */ 5:
				message.lot = reader.int32();
				break;
			case /* string currency */ 6:
				message.currency = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
				message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
				message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
				message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
				message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
				message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
				message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
				break;
			case /* bool short_enabled_flag */ 13:
				message.shortEnabledFlag = reader.bool();
				break;
			case /* string name */ 15:
				message.name = reader.string();
				break;
			case /* string exchange */ 16:
				message.exchange = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal */ 17:
				message.nominal = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
				break;
			case /* string country_of_risk */ 18:
				message.countryOfRisk = reader.string();
				break;
			case /* string country_of_risk_name */ 19:
				message.countryOfRiskName = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 20:
				message.tradingStatus = reader.int32();
				break;
			case /* bool otc_flag */ 21:
				message.otcFlag = reader.bool();
				break;
			case /* bool buy_available_flag */ 22:
				message.buyAvailableFlag = reader.bool();
				break;
			case /* bool sell_available_flag */ 23:
				message.sellAvailableFlag = reader.bool();
				break;
			case /* string iso_currency_name */ 24:
				message.isoCurrencyName = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 25:
				message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
				break;
			case /* bool api_trade_available_flag */ 26:
				message.apiTradeAvailableFlag = reader.bool();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: Currency, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		/* string ticker = 2; */
		if (message.ticker !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.ticker);
		/* string class_code = 3; */
		if (message.classCode !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.classCode);
		/* string isin = 4; */
		if (message.isin !== '')
			writer.tag(4, WireType.LengthDelimited).string(message.isin);
		/* int32 lot = 5; */
		if (message.lot !== 0)
			writer.tag(5, WireType.Varint).int32(message.lot);
		/* string currency = 6; */
		if (message.currency !== '')
			writer.tag(6, WireType.LengthDelimited).string(message.currency);
		/* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
		if (message.klong)
			Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
		if (message.kshort)
			Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
		if (message.dlong)
			Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
		if (message.dshort)
			Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
		if (message.dlongMin)
			Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
		if (message.dshortMin)
			Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
		/* bool short_enabled_flag = 13; */
		if (message.shortEnabledFlag !== false)
			writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
		/* string name = 15; */
		if (message.name !== '')
			writer.tag(15, WireType.LengthDelimited).string(message.name);
		/* string exchange = 16; */
		if (message.exchange !== '')
			writer.tag(16, WireType.LengthDelimited).string(message.exchange);
		/* tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 17; */
		if (message.nominal)
			MoneyValue.internalBinaryWrite(message.nominal, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
		/* string country_of_risk = 18; */
		if (message.countryOfRisk !== '')
			writer.tag(18, WireType.LengthDelimited).string(message.countryOfRisk);
		/* string country_of_risk_name = 19; */
		if (message.countryOfRiskName !== '')
			writer.tag(19, WireType.LengthDelimited).string(message.countryOfRiskName);
		/* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 20; */
		if (message.tradingStatus !== 0)
			writer.tag(20, WireType.Varint).int32(message.tradingStatus);
		/* bool otc_flag = 21; */
		if (message.otcFlag !== false)
			writer.tag(21, WireType.Varint).bool(message.otcFlag);
		/* bool buy_available_flag = 22; */
		if (message.buyAvailableFlag !== false)
			writer.tag(22, WireType.Varint).bool(message.buyAvailableFlag);
		/* bool sell_available_flag = 23; */
		if (message.sellAvailableFlag !== false)
			writer.tag(23, WireType.Varint).bool(message.sellAvailableFlag);
		/* string iso_currency_name = 24; */
		if (message.isoCurrencyName !== '')
			writer.tag(24, WireType.LengthDelimited).string(message.isoCurrencyName);
		/* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 25; */
		if (message.minPriceIncrement)
			Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(25, WireType.LengthDelimited).fork(), options).join();
		/* bool api_trade_available_flag = 26; */
		if (message.apiTradeAvailableFlag !== false)
			writer.tag(26, WireType.Varint).bool(message.apiTradeAvailableFlag);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Currency
 */
export const Currency = new Currency$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Etf$Type extends MessageType<Etf> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.Etf', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'ticker', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'class_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'isin', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 5, name: 'lot', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{ no: 6, name: 'currency', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 7, name: 'klong', kind: 'message', T: () => Quotation },
			{ no: 8, name: 'kshort', kind: 'message', T: () => Quotation },
			{ no: 9, name: 'dlong', kind: 'message', T: () => Quotation },
			{ no: 10, name: 'dshort', kind: 'message', T: () => Quotation },
			{ no: 11, name: 'dlong_min', kind: 'message', T: () => Quotation },
			{ no: 12, name: 'dshort_min', kind: 'message', T: () => Quotation },
			{ no: 13, name: 'short_enabled_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 15, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 16, name: 'exchange', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 17, name: 'fixed_commission', kind: 'message', T: () => Quotation },
			{ no: 18, name: 'focus_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 19, name: 'released_date', kind: 'message', T: () => Timestamp },
			{ no: 20, name: 'num_shares', kind: 'message', T: () => Quotation },
			{ no: 21, name: 'country_of_risk', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 22, name: 'country_of_risk_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 23, name: 'sector', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 24, name: 'rebalancing_freq', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 25, name: 'trading_status', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.SecurityTradingStatus', SecurityTradingStatus, 'SECURITY_TRADING_STATUS_'] },
			{ no: 26, name: 'otc_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 27, name: 'buy_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 28, name: 'sell_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 29, name: 'min_price_increment', kind: 'message', T: () => Quotation },
			{ no: 30, name: 'api_trade_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
		]);
	}
	create(value?: PartialMessage<Etf>): Etf {
		const message = { figi: '', ticker: '', classCode: '', isin: '', lot: 0, currency: '', shortEnabledFlag: false, name: '', exchange: '', focusType: '', countryOfRisk: '', countryOfRiskName: '', sector: '', rebalancingFreq: '', tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, apiTradeAvailableFlag: false };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<Etf>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Etf): Etf {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			case /* string ticker */ 2:
				message.ticker = reader.string();
				break;
			case /* string class_code */ 3:
				message.classCode = reader.string();
				break;
			case /* string isin */ 4:
				message.isin = reader.string();
				break;
			case /* int32 lot */ 5:
				message.lot = reader.int32();
				break;
			case /* string currency */ 6:
				message.currency = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
				message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
				message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
				message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
				message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
				message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
				message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
				break;
			case /* bool short_enabled_flag */ 13:
				message.shortEnabledFlag = reader.bool();
				break;
			case /* string name */ 15:
				message.name = reader.string();
				break;
			case /* string exchange */ 16:
				message.exchange = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation fixed_commission */ 17:
				message.fixedCommission = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.fixedCommission);
				break;
			case /* string focus_type */ 18:
				message.focusType = reader.string();
				break;
			case /* google.protobuf.Timestamp released_date */ 19:
				message.releasedDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.releasedDate);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation num_shares */ 20:
				message.numShares = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.numShares);
				break;
			case /* string country_of_risk */ 21:
				message.countryOfRisk = reader.string();
				break;
			case /* string country_of_risk_name */ 22:
				message.countryOfRiskName = reader.string();
				break;
			case /* string sector */ 23:
				message.sector = reader.string();
				break;
			case /* string rebalancing_freq */ 24:
				message.rebalancingFreq = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 25:
				message.tradingStatus = reader.int32();
				break;
			case /* bool otc_flag */ 26:
				message.otcFlag = reader.bool();
				break;
			case /* bool buy_available_flag */ 27:
				message.buyAvailableFlag = reader.bool();
				break;
			case /* bool sell_available_flag */ 28:
				message.sellAvailableFlag = reader.bool();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 29:
				message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
				break;
			case /* bool api_trade_available_flag */ 30:
				message.apiTradeAvailableFlag = reader.bool();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: Etf, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		/* string ticker = 2; */
		if (message.ticker !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.ticker);
		/* string class_code = 3; */
		if (message.classCode !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.classCode);
		/* string isin = 4; */
		if (message.isin !== '')
			writer.tag(4, WireType.LengthDelimited).string(message.isin);
		/* int32 lot = 5; */
		if (message.lot !== 0)
			writer.tag(5, WireType.Varint).int32(message.lot);
		/* string currency = 6; */
		if (message.currency !== '')
			writer.tag(6, WireType.LengthDelimited).string(message.currency);
		/* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
		if (message.klong)
			Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
		if (message.kshort)
			Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
		if (message.dlong)
			Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
		if (message.dshort)
			Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
		if (message.dlongMin)
			Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
		if (message.dshortMin)
			Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
		/* bool short_enabled_flag = 13; */
		if (message.shortEnabledFlag !== false)
			writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
		/* string name = 15; */
		if (message.name !== '')
			writer.tag(15, WireType.LengthDelimited).string(message.name);
		/* string exchange = 16; */
		if (message.exchange !== '')
			writer.tag(16, WireType.LengthDelimited).string(message.exchange);
		/* tinkoff.public.invest.api.contract.v1.Quotation fixed_commission = 17; */
		if (message.fixedCommission)
			Quotation.internalBinaryWrite(message.fixedCommission, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
		/* string focus_type = 18; */
		if (message.focusType !== '')
			writer.tag(18, WireType.LengthDelimited).string(message.focusType);
		/* google.protobuf.Timestamp released_date = 19; */
		if (message.releasedDate)
			Timestamp.internalBinaryWrite(message.releasedDate, writer.tag(19, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation num_shares = 20; */
		if (message.numShares)
			Quotation.internalBinaryWrite(message.numShares, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
		/* string country_of_risk = 21; */
		if (message.countryOfRisk !== '')
			writer.tag(21, WireType.LengthDelimited).string(message.countryOfRisk);
		/* string country_of_risk_name = 22; */
		if (message.countryOfRiskName !== '')
			writer.tag(22, WireType.LengthDelimited).string(message.countryOfRiskName);
		/* string sector = 23; */
		if (message.sector !== '')
			writer.tag(23, WireType.LengthDelimited).string(message.sector);
		/* string rebalancing_freq = 24; */
		if (message.rebalancingFreq !== '')
			writer.tag(24, WireType.LengthDelimited).string(message.rebalancingFreq);
		/* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25; */
		if (message.tradingStatus !== 0)
			writer.tag(25, WireType.Varint).int32(message.tradingStatus);
		/* bool otc_flag = 26; */
		if (message.otcFlag !== false)
			writer.tag(26, WireType.Varint).bool(message.otcFlag);
		/* bool buy_available_flag = 27; */
		if (message.buyAvailableFlag !== false)
			writer.tag(27, WireType.Varint).bool(message.buyAvailableFlag);
		/* bool sell_available_flag = 28; */
		if (message.sellAvailableFlag !== false)
			writer.tag(28, WireType.Varint).bool(message.sellAvailableFlag);
		/* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 29; */
		if (message.minPriceIncrement)
			Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
		/* bool api_trade_available_flag = 30; */
		if (message.apiTradeAvailableFlag !== false)
			writer.tag(30, WireType.Varint).bool(message.apiTradeAvailableFlag);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Etf
 */
export const Etf = new Etf$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Future$Type extends MessageType<Future> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.Future', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'ticker', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'class_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'lot', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{ no: 5, name: 'currency', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 6, name: 'klong', kind: 'message', T: () => Quotation },
			{ no: 7, name: 'kshort', kind: 'message', T: () => Quotation },
			{ no: 8, name: 'dlong', kind: 'message', T: () => Quotation },
			{ no: 9, name: 'dshort', kind: 'message', T: () => Quotation },
			{ no: 10, name: 'dlong_min', kind: 'message', T: () => Quotation },
			{ no: 11, name: 'dshort_min', kind: 'message', T: () => Quotation },
			{ no: 12, name: 'short_enabled_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 13, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 14, name: 'exchange', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 15, name: 'first_trade_date', kind: 'message', T: () => Timestamp },
			{ no: 16, name: 'last_trade_date', kind: 'message', T: () => Timestamp },
			{ no: 17, name: 'futures_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 18, name: 'asset_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 19, name: 'basic_asset', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 20, name: 'basic_asset_size', kind: 'message', T: () => Quotation },
			{ no: 21, name: 'country_of_risk', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 22, name: 'country_of_risk_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 23, name: 'sector', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 24, name: 'expiration_date', kind: 'message', T: () => Timestamp },
			{ no: 25, name: 'trading_status', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.SecurityTradingStatus', SecurityTradingStatus, 'SECURITY_TRADING_STATUS_'] },
			{ no: 26, name: 'otc_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 27, name: 'buy_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 28, name: 'sell_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 29, name: 'min_price_increment', kind: 'message', T: () => Quotation },
			{ no: 30, name: 'api_trade_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
		]);
	}
	create(value?: PartialMessage<Future>): Future {
		const message = { figi: '', ticker: '', classCode: '', lot: 0, currency: '', shortEnabledFlag: false, name: '', exchange: '', futuresType: '', assetType: '', basicAsset: '', countryOfRisk: '', countryOfRiskName: '', sector: '', tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, apiTradeAvailableFlag: false };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<Future>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Future): Future {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			case /* string ticker */ 2:
				message.ticker = reader.string();
				break;
			case /* string class_code */ 3:
				message.classCode = reader.string();
				break;
			case /* int32 lot */ 4:
				message.lot = reader.int32();
				break;
			case /* string currency */ 5:
				message.currency = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 6:
				message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 7:
				message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 8:
				message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 9:
				message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 10:
				message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 11:
				message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
				break;
			case /* bool short_enabled_flag */ 12:
				message.shortEnabledFlag = reader.bool();
				break;
			case /* string name */ 13:
				message.name = reader.string();
				break;
			case /* string exchange */ 14:
				message.exchange = reader.string();
				break;
			case /* google.protobuf.Timestamp first_trade_date */ 15:
				message.firstTradeDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.firstTradeDate);
				break;
			case /* google.protobuf.Timestamp last_trade_date */ 16:
				message.lastTradeDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastTradeDate);
				break;
			case /* string futures_type */ 17:
				message.futuresType = reader.string();
				break;
			case /* string asset_type */ 18:
				message.assetType = reader.string();
				break;
			case /* string basic_asset */ 19:
				message.basicAsset = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size */ 20:
				message.basicAssetSize = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.basicAssetSize);
				break;
			case /* string country_of_risk */ 21:
				message.countryOfRisk = reader.string();
				break;
			case /* string country_of_risk_name */ 22:
				message.countryOfRiskName = reader.string();
				break;
			case /* string sector */ 23:
				message.sector = reader.string();
				break;
			case /* google.protobuf.Timestamp expiration_date */ 24:
				message.expirationDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.expirationDate);
				break;
			case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 25:
				message.tradingStatus = reader.int32();
				break;
			case /* bool otc_flag */ 26:
				message.otcFlag = reader.bool();
				break;
			case /* bool buy_available_flag */ 27:
				message.buyAvailableFlag = reader.bool();
				break;
			case /* bool sell_available_flag */ 28:
				message.sellAvailableFlag = reader.bool();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 29:
				message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
				break;
			case /* bool api_trade_available_flag */ 30:
				message.apiTradeAvailableFlag = reader.bool();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: Future, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		/* string ticker = 2; */
		if (message.ticker !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.ticker);
		/* string class_code = 3; */
		if (message.classCode !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.classCode);
		/* int32 lot = 4; */
		if (message.lot !== 0)
			writer.tag(4, WireType.Varint).int32(message.lot);
		/* string currency = 5; */
		if (message.currency !== '')
			writer.tag(5, WireType.LengthDelimited).string(message.currency);
		/* tinkoff.public.invest.api.contract.v1.Quotation klong = 6; */
		if (message.klong)
			Quotation.internalBinaryWrite(message.klong, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation kshort = 7; */
		if (message.kshort)
			Quotation.internalBinaryWrite(message.kshort, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong = 8; */
		if (message.dlong)
			Quotation.internalBinaryWrite(message.dlong, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort = 9; */
		if (message.dshort)
			Quotation.internalBinaryWrite(message.dshort, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 10; */
		if (message.dlongMin)
			Quotation.internalBinaryWrite(message.dlongMin, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 11; */
		if (message.dshortMin)
			Quotation.internalBinaryWrite(message.dshortMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
		/* bool short_enabled_flag = 12; */
		if (message.shortEnabledFlag !== false)
			writer.tag(12, WireType.Varint).bool(message.shortEnabledFlag);
		/* string name = 13; */
		if (message.name !== '')
			writer.tag(13, WireType.LengthDelimited).string(message.name);
		/* string exchange = 14; */
		if (message.exchange !== '')
			writer.tag(14, WireType.LengthDelimited).string(message.exchange);
		/* google.protobuf.Timestamp first_trade_date = 15; */
		if (message.firstTradeDate)
			Timestamp.internalBinaryWrite(message.firstTradeDate, writer.tag(15, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp last_trade_date = 16; */
		if (message.lastTradeDate)
			Timestamp.internalBinaryWrite(message.lastTradeDate, writer.tag(16, WireType.LengthDelimited).fork(), options).join();
		/* string futures_type = 17; */
		if (message.futuresType !== '')
			writer.tag(17, WireType.LengthDelimited).string(message.futuresType);
		/* string asset_type = 18; */
		if (message.assetType !== '')
			writer.tag(18, WireType.LengthDelimited).string(message.assetType);
		/* string basic_asset = 19; */
		if (message.basicAsset !== '')
			writer.tag(19, WireType.LengthDelimited).string(message.basicAsset);
		/* tinkoff.public.invest.api.contract.v1.Quotation basic_asset_size = 20; */
		if (message.basicAssetSize)
			Quotation.internalBinaryWrite(message.basicAssetSize, writer.tag(20, WireType.LengthDelimited).fork(), options).join();
		/* string country_of_risk = 21; */
		if (message.countryOfRisk !== '')
			writer.tag(21, WireType.LengthDelimited).string(message.countryOfRisk);
		/* string country_of_risk_name = 22; */
		if (message.countryOfRiskName !== '')
			writer.tag(22, WireType.LengthDelimited).string(message.countryOfRiskName);
		/* string sector = 23; */
		if (message.sector !== '')
			writer.tag(23, WireType.LengthDelimited).string(message.sector);
		/* google.protobuf.Timestamp expiration_date = 24; */
		if (message.expirationDate)
			Timestamp.internalBinaryWrite(message.expirationDate, writer.tag(24, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25; */
		if (message.tradingStatus !== 0)
			writer.tag(25, WireType.Varint).int32(message.tradingStatus);
		/* bool otc_flag = 26; */
		if (message.otcFlag !== false)
			writer.tag(26, WireType.Varint).bool(message.otcFlag);
		/* bool buy_available_flag = 27; */
		if (message.buyAvailableFlag !== false)
			writer.tag(27, WireType.Varint).bool(message.buyAvailableFlag);
		/* bool sell_available_flag = 28; */
		if (message.sellAvailableFlag !== false)
			writer.tag(28, WireType.Varint).bool(message.sellAvailableFlag);
		/* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 29; */
		if (message.minPriceIncrement)
			Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(29, WireType.LengthDelimited).fork(), options).join();
		/* bool api_trade_available_flag = 30; */
		if (message.apiTradeAvailableFlag !== false)
			writer.tag(30, WireType.Varint).bool(message.apiTradeAvailableFlag);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Future
 */
export const Future = new Future$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Share$Type extends MessageType<Share> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.Share', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'ticker', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'class_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'isin', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 5, name: 'lot', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{ no: 6, name: 'currency', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 7, name: 'klong', kind: 'message', T: () => Quotation },
			{ no: 8, name: 'kshort', kind: 'message', T: () => Quotation },
			{ no: 9, name: 'dlong', kind: 'message', T: () => Quotation },
			{ no: 10, name: 'dshort', kind: 'message', T: () => Quotation },
			{ no: 11, name: 'dlong_min', kind: 'message', T: () => Quotation },
			{ no: 12, name: 'dshort_min', kind: 'message', T: () => Quotation },
			{ no: 13, name: 'short_enabled_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 15, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 16, name: 'exchange', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 17, name: 'ipo_date', kind: 'message', T: () => Timestamp },
			{ no: 18, name: 'issue_size', kind: 'scalar', T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
			{ no: 19, name: 'country_of_risk', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 20, name: 'country_of_risk_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 21, name: 'sector', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 22, name: 'issue_size_plan', kind: 'scalar', T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
			{ no: 23, name: 'nominal', kind: 'message', T: () => MoneyValue },
			{ no: 25, name: 'trading_status', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.SecurityTradingStatus', SecurityTradingStatus, 'SECURITY_TRADING_STATUS_'] },
			{ no: 26, name: 'otc_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 27, name: 'buy_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 28, name: 'sell_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 29, name: 'div_yield_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 30, name: 'share_type', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.ShareType', ShareType, 'SHARE_TYPE_'] },
			{ no: 31, name: 'min_price_increment', kind: 'message', T: () => Quotation },
			{ no: 32, name: 'api_trade_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
		]);
	}
	create(value?: PartialMessage<Share>): Share {
		const message = { figi: '', ticker: '', classCode: '', isin: '', lot: 0, currency: '', shortEnabledFlag: false, name: '', exchange: '', issueSize: 0n, countryOfRisk: '', countryOfRiskName: '', sector: '', issueSizePlan: 0n, tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, divYieldFlag: false, shareType: 0, apiTradeAvailableFlag: false };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<Share>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Share): Share {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			case /* string ticker */ 2:
				message.ticker = reader.string();
				break;
			case /* string class_code */ 3:
				message.classCode = reader.string();
				break;
			case /* string isin */ 4:
				message.isin = reader.string();
				break;
			case /* int32 lot */ 5:
				message.lot = reader.int32();
				break;
			case /* string currency */ 6:
				message.currency = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
				message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
				message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
				message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
				message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
				message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
				message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
				break;
			case /* bool short_enabled_flag */ 13:
				message.shortEnabledFlag = reader.bool();
				break;
			case /* string name */ 15:
				message.name = reader.string();
				break;
			case /* string exchange */ 16:
				message.exchange = reader.string();
				break;
			case /* google.protobuf.Timestamp ipo_date */ 17:
				message.ipoDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.ipoDate);
				break;
			case /* int64 issue_size */ 18:
				message.issueSize = reader.int64().toBigInt();
				break;
			case /* string country_of_risk */ 19:
				message.countryOfRisk = reader.string();
				break;
			case /* string country_of_risk_name */ 20:
				message.countryOfRiskName = reader.string();
				break;
			case /* string sector */ 21:
				message.sector = reader.string();
				break;
			case /* int64 issue_size_plan */ 22:
				message.issueSizePlan = reader.int64().toBigInt();
				break;
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue nominal */ 23:
				message.nominal = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
				break;
			case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 25:
				message.tradingStatus = reader.int32();
				break;
			case /* bool otc_flag */ 26:
				message.otcFlag = reader.bool();
				break;
			case /* bool buy_available_flag */ 27:
				message.buyAvailableFlag = reader.bool();
				break;
			case /* bool sell_available_flag */ 28:
				message.sellAvailableFlag = reader.bool();
				break;
			case /* bool div_yield_flag */ 29:
				message.divYieldFlag = reader.bool();
				break;
			case /* tinkoff.public.invest.api.contract.v1.ShareType share_type */ 30:
				message.shareType = reader.int32();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 31:
				message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
				break;
			case /* bool api_trade_available_flag */ 32:
				message.apiTradeAvailableFlag = reader.bool();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: Share, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		/* string ticker = 2; */
		if (message.ticker !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.ticker);
		/* string class_code = 3; */
		if (message.classCode !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.classCode);
		/* string isin = 4; */
		if (message.isin !== '')
			writer.tag(4, WireType.LengthDelimited).string(message.isin);
		/* int32 lot = 5; */
		if (message.lot !== 0)
			writer.tag(5, WireType.Varint).int32(message.lot);
		/* string currency = 6; */
		if (message.currency !== '')
			writer.tag(6, WireType.LengthDelimited).string(message.currency);
		/* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
		if (message.klong)
			Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
		if (message.kshort)
			Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
		if (message.dlong)
			Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
		if (message.dshort)
			Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
		if (message.dlongMin)
			Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
		if (message.dshortMin)
			Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
		/* bool short_enabled_flag = 13; */
		if (message.shortEnabledFlag !== false)
			writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
		/* string name = 15; */
		if (message.name !== '')
			writer.tag(15, WireType.LengthDelimited).string(message.name);
		/* string exchange = 16; */
		if (message.exchange !== '')
			writer.tag(16, WireType.LengthDelimited).string(message.exchange);
		/* google.protobuf.Timestamp ipo_date = 17; */
		if (message.ipoDate)
			Timestamp.internalBinaryWrite(message.ipoDate, writer.tag(17, WireType.LengthDelimited).fork(), options).join();
		/* int64 issue_size = 18; */
		if (message.issueSize !== 0n)
			writer.tag(18, WireType.Varint).int64(message.issueSize);
		/* string country_of_risk = 19; */
		if (message.countryOfRisk !== '')
			writer.tag(19, WireType.LengthDelimited).string(message.countryOfRisk);
		/* string country_of_risk_name = 20; */
		if (message.countryOfRiskName !== '')
			writer.tag(20, WireType.LengthDelimited).string(message.countryOfRiskName);
		/* string sector = 21; */
		if (message.sector !== '')
			writer.tag(21, WireType.LengthDelimited).string(message.sector);
		/* int64 issue_size_plan = 22; */
		if (message.issueSizePlan !== 0n)
			writer.tag(22, WireType.Varint).int64(message.issueSizePlan);
		/* tinkoff.public.invest.api.contract.v1.MoneyValue nominal = 23; */
		if (message.nominal)
			MoneyValue.internalBinaryWrite(message.nominal, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 25; */
		if (message.tradingStatus !== 0)
			writer.tag(25, WireType.Varint).int32(message.tradingStatus);
		/* bool otc_flag = 26; */
		if (message.otcFlag !== false)
			writer.tag(26, WireType.Varint).bool(message.otcFlag);
		/* bool buy_available_flag = 27; */
		if (message.buyAvailableFlag !== false)
			writer.tag(27, WireType.Varint).bool(message.buyAvailableFlag);
		/* bool sell_available_flag = 28; */
		if (message.sellAvailableFlag !== false)
			writer.tag(28, WireType.Varint).bool(message.sellAvailableFlag);
		/* bool div_yield_flag = 29; */
		if (message.divYieldFlag !== false)
			writer.tag(29, WireType.Varint).bool(message.divYieldFlag);
		/* tinkoff.public.invest.api.contract.v1.ShareType share_type = 30; */
		if (message.shareType !== 0)
			writer.tag(30, WireType.Varint).int32(message.shareType);
		/* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 31; */
		if (message.minPriceIncrement)
			Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(31, WireType.LengthDelimited).fork(), options).join();
		/* bool api_trade_available_flag = 32; */
		if (message.apiTradeAvailableFlag !== false)
			writer.tag(32, WireType.Varint).bool(message.apiTradeAvailableFlag);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Share
 */
export const Share = new Share$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccruedInterestsRequest$Type extends MessageType<GetAccruedInterestsRequest> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.GetAccruedInterestsRequest', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'from', kind: 'message', T: () => Timestamp },
			{ no: 3, name: 'to', kind: 'message', T: () => Timestamp }
		]);
	}
	create(value?: PartialMessage<GetAccruedInterestsRequest>): GetAccruedInterestsRequest {
		const message = { figi: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<GetAccruedInterestsRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccruedInterestsRequest): GetAccruedInterestsRequest {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			case /* google.protobuf.Timestamp from */ 2:
				message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
				break;
			case /* google.protobuf.Timestamp to */ 3:
				message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: GetAccruedInterestsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		/* google.protobuf.Timestamp from = 2; */
		if (message.from)
			Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp to = 3; */
		if (message.to)
			Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetAccruedInterestsRequest
 */
export const GetAccruedInterestsRequest = new GetAccruedInterestsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetAccruedInterestsResponse$Type extends MessageType<GetAccruedInterestsResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.GetAccruedInterestsResponse', [
			{ no: 1, name: 'accrued_interests', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => AccruedInterest }
		]);
	}
	create(value?: PartialMessage<GetAccruedInterestsResponse>): GetAccruedInterestsResponse {
		const message = { accruedInterests: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<GetAccruedInterestsResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetAccruedInterestsResponse): GetAccruedInterestsResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* repeated tinkoff.public.invest.api.contract.v1.AccruedInterest accrued_interests */ 1:
				message.accruedInterests.push(AccruedInterest.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: GetAccruedInterestsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated tinkoff.public.invest.api.contract.v1.AccruedInterest accrued_interests = 1; */
		for (let i = 0; i < message.accruedInterests.length; i++)
			AccruedInterest.internalBinaryWrite(message.accruedInterests[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetAccruedInterestsResponse
 */
export const GetAccruedInterestsResponse = new GetAccruedInterestsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class AccruedInterest$Type extends MessageType<AccruedInterest> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.AccruedInterest', [
			{ no: 1, name: 'date', kind: 'message', T: () => Timestamp },
			{ no: 2, name: 'value', kind: 'message', T: () => Quotation },
			{ no: 3, name: 'value_percent', kind: 'message', T: () => Quotation },
			{ no: 4, name: 'nominal', kind: 'message', T: () => Quotation }
		]);
	}
	create(value?: PartialMessage<AccruedInterest>): AccruedInterest {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<AccruedInterest>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AccruedInterest): AccruedInterest {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* google.protobuf.Timestamp date */ 1:
				message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation value */ 2:
				message.value = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.value);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation value_percent */ 3:
				message.valuePercent = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.valuePercent);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation nominal */ 4:
				message.nominal = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.nominal);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: AccruedInterest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* google.protobuf.Timestamp date = 1; */
		if (message.date)
			Timestamp.internalBinaryWrite(message.date, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation value = 2; */
		if (message.value)
			Quotation.internalBinaryWrite(message.value, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation value_percent = 3; */
		if (message.valuePercent)
			Quotation.internalBinaryWrite(message.valuePercent, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation nominal = 4; */
		if (message.nominal)
			Quotation.internalBinaryWrite(message.nominal, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.AccruedInterest
 */
export const AccruedInterest = new AccruedInterest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFuturesMarginRequest$Type extends MessageType<GetFuturesMarginRequest> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.GetFuturesMarginRequest', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ }
		]);
	}
	create(value?: PartialMessage<GetFuturesMarginRequest>): GetFuturesMarginRequest {
		const message = { figi: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<GetFuturesMarginRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFuturesMarginRequest): GetFuturesMarginRequest {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: GetFuturesMarginRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetFuturesMarginRequest
 */
export const GetFuturesMarginRequest = new GetFuturesMarginRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetFuturesMarginResponse$Type extends MessageType<GetFuturesMarginResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.GetFuturesMarginResponse', [
			{ no: 1, name: 'initial_margin_on_buy', kind: 'message', T: () => MoneyValue },
			{ no: 2, name: 'initial_margin_on_sell', kind: 'message', T: () => MoneyValue },
			{ no: 3, name: 'min_price_increment', kind: 'message', T: () => Quotation },
			{ no: 4, name: 'min_price_increment_amount', kind: 'message', T: () => Quotation }
		]);
	}
	create(value?: PartialMessage<GetFuturesMarginResponse>): GetFuturesMarginResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<GetFuturesMarginResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetFuturesMarginResponse): GetFuturesMarginResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_buy */ 1:
				message.initialMarginOnBuy = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialMarginOnBuy);
				break;
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_sell */ 2:
				message.initialMarginOnSell = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.initialMarginOnSell);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 3:
				message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment_amount */ 4:
				message.minPriceIncrementAmount = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrementAmount);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: GetFuturesMarginResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_buy = 1; */
		if (message.initialMarginOnBuy)
			MoneyValue.internalBinaryWrite(message.initialMarginOnBuy, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.MoneyValue initial_margin_on_sell = 2; */
		if (message.initialMarginOnSell)
			MoneyValue.internalBinaryWrite(message.initialMarginOnSell, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 3; */
		if (message.minPriceIncrement)
			Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment_amount = 4; */
		if (message.minPriceIncrementAmount)
			Quotation.internalBinaryWrite(message.minPriceIncrementAmount, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetFuturesMarginResponse
 */
export const GetFuturesMarginResponse = new GetFuturesMarginResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InstrumentResponse$Type extends MessageType<InstrumentResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.InstrumentResponse', [
			{ no: 1, name: 'instrument', kind: 'message', T: () => Instrument }
		]);
	}
	create(value?: PartialMessage<InstrumentResponse>): InstrumentResponse {
		const message = {};
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<InstrumentResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InstrumentResponse): InstrumentResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.Instrument instrument */ 1:
				message.instrument = Instrument.internalBinaryRead(reader, reader.uint32(), options, message.instrument);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: InstrumentResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.Instrument instrument = 1; */
		if (message.instrument)
			Instrument.internalBinaryWrite(message.instrument, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.InstrumentResponse
 */
export const InstrumentResponse = new InstrumentResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Instrument$Type extends MessageType<Instrument> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.Instrument', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'ticker', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 3, name: 'class_code', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 4, name: 'isin', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 5, name: 'lot', kind: 'scalar', T: 5 /*ScalarType.INT32*/ },
			{ no: 6, name: 'currency', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 7, name: 'klong', kind: 'message', T: () => Quotation },
			{ no: 8, name: 'kshort', kind: 'message', T: () => Quotation },
			{ no: 9, name: 'dlong', kind: 'message', T: () => Quotation },
			{ no: 10, name: 'dshort', kind: 'message', T: () => Quotation },
			{ no: 11, name: 'dlong_min', kind: 'message', T: () => Quotation },
			{ no: 12, name: 'dshort_min', kind: 'message', T: () => Quotation },
			{ no: 13, name: 'short_enabled_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 14, name: 'name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 15, name: 'exchange', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 16, name: 'country_of_risk', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 17, name: 'country_of_risk_name', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 18, name: 'instrument_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 19, name: 'trading_status', kind: 'enum', T: () => ['tinkoff.public.invest.api.contract.v1.SecurityTradingStatus', SecurityTradingStatus, 'SECURITY_TRADING_STATUS_'] },
			{ no: 20, name: 'otc_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 21, name: 'buy_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 22, name: 'sell_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ },
			{ no: 23, name: 'min_price_increment', kind: 'message', T: () => Quotation },
			{ no: 24, name: 'api_trade_available_flag', kind: 'scalar', T: 8 /*ScalarType.BOOL*/ }
		]);
	}
	create(value?: PartialMessage<Instrument>): Instrument {
		const message = { figi: '', ticker: '', classCode: '', isin: '', lot: 0, currency: '', shortEnabledFlag: false, name: '', exchange: '', countryOfRisk: '', countryOfRiskName: '', instrumentType: '', tradingStatus: 0, otcFlag: false, buyAvailableFlag: false, sellAvailableFlag: false, apiTradeAvailableFlag: false };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<Instrument>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Instrument): Instrument {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			case /* string ticker */ 2:
				message.ticker = reader.string();
				break;
			case /* string class_code */ 3:
				message.classCode = reader.string();
				break;
			case /* string isin */ 4:
				message.isin = reader.string();
				break;
			case /* int32 lot */ 5:
				message.lot = reader.int32();
				break;
			case /* string currency */ 6:
				message.currency = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation klong */ 7:
				message.klong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.klong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation kshort */ 8:
				message.kshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.kshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong */ 9:
				message.dlong = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlong);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort */ 10:
				message.dshort = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshort);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dlong_min */ 11:
				message.dlongMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dlongMin);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation dshort_min */ 12:
				message.dshortMin = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.dshortMin);
				break;
			case /* bool short_enabled_flag */ 13:
				message.shortEnabledFlag = reader.bool();
				break;
			case /* string name */ 14:
				message.name = reader.string();
				break;
			case /* string exchange */ 15:
				message.exchange = reader.string();
				break;
			case /* string country_of_risk */ 16:
				message.countryOfRisk = reader.string();
				break;
			case /* string country_of_risk_name */ 17:
				message.countryOfRiskName = reader.string();
				break;
			case /* string instrument_type */ 18:
				message.instrumentType = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status */ 19:
				message.tradingStatus = reader.int32();
				break;
			case /* bool otc_flag */ 20:
				message.otcFlag = reader.bool();
				break;
			case /* bool buy_available_flag */ 21:
				message.buyAvailableFlag = reader.bool();
				break;
			case /* bool sell_available_flag */ 22:
				message.sellAvailableFlag = reader.bool();
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment */ 23:
				message.minPriceIncrement = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.minPriceIncrement);
				break;
			case /* bool api_trade_available_flag */ 24:
				message.apiTradeAvailableFlag = reader.bool();
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: Instrument, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		/* string ticker = 2; */
		if (message.ticker !== '')
			writer.tag(2, WireType.LengthDelimited).string(message.ticker);
		/* string class_code = 3; */
		if (message.classCode !== '')
			writer.tag(3, WireType.LengthDelimited).string(message.classCode);
		/* string isin = 4; */
		if (message.isin !== '')
			writer.tag(4, WireType.LengthDelimited).string(message.isin);
		/* int32 lot = 5; */
		if (message.lot !== 0)
			writer.tag(5, WireType.Varint).int32(message.lot);
		/* string currency = 6; */
		if (message.currency !== '')
			writer.tag(6, WireType.LengthDelimited).string(message.currency);
		/* tinkoff.public.invest.api.contract.v1.Quotation klong = 7; */
		if (message.klong)
			Quotation.internalBinaryWrite(message.klong, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation kshort = 8; */
		if (message.kshort)
			Quotation.internalBinaryWrite(message.kshort, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong = 9; */
		if (message.dlong)
			Quotation.internalBinaryWrite(message.dlong, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort = 10; */
		if (message.dshort)
			Quotation.internalBinaryWrite(message.dshort, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dlong_min = 11; */
		if (message.dlongMin)
			Quotation.internalBinaryWrite(message.dlongMin, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation dshort_min = 12; */
		if (message.dshortMin)
			Quotation.internalBinaryWrite(message.dshortMin, writer.tag(12, WireType.LengthDelimited).fork(), options).join();
		/* bool short_enabled_flag = 13; */
		if (message.shortEnabledFlag !== false)
			writer.tag(13, WireType.Varint).bool(message.shortEnabledFlag);
		/* string name = 14; */
		if (message.name !== '')
			writer.tag(14, WireType.LengthDelimited).string(message.name);
		/* string exchange = 15; */
		if (message.exchange !== '')
			writer.tag(15, WireType.LengthDelimited).string(message.exchange);
		/* string country_of_risk = 16; */
		if (message.countryOfRisk !== '')
			writer.tag(16, WireType.LengthDelimited).string(message.countryOfRisk);
		/* string country_of_risk_name = 17; */
		if (message.countryOfRiskName !== '')
			writer.tag(17, WireType.LengthDelimited).string(message.countryOfRiskName);
		/* string instrument_type = 18; */
		if (message.instrumentType !== '')
			writer.tag(18, WireType.LengthDelimited).string(message.instrumentType);
		/* tinkoff.public.invest.api.contract.v1.SecurityTradingStatus trading_status = 19; */
		if (message.tradingStatus !== 0)
			writer.tag(19, WireType.Varint).int32(message.tradingStatus);
		/* bool otc_flag = 20; */
		if (message.otcFlag !== false)
			writer.tag(20, WireType.Varint).bool(message.otcFlag);
		/* bool buy_available_flag = 21; */
		if (message.buyAvailableFlag !== false)
			writer.tag(21, WireType.Varint).bool(message.buyAvailableFlag);
		/* bool sell_available_flag = 22; */
		if (message.sellAvailableFlag !== false)
			writer.tag(22, WireType.Varint).bool(message.sellAvailableFlag);
		/* tinkoff.public.invest.api.contract.v1.Quotation min_price_increment = 23; */
		if (message.minPriceIncrement)
			Quotation.internalBinaryWrite(message.minPriceIncrement, writer.tag(23, WireType.LengthDelimited).fork(), options).join();
		/* bool api_trade_available_flag = 24; */
		if (message.apiTradeAvailableFlag !== false)
			writer.tag(24, WireType.Varint).bool(message.apiTradeAvailableFlag);
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Instrument
 */
export const Instrument = new Instrument$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDividendsRequest$Type extends MessageType<GetDividendsRequest> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.GetDividendsRequest', [
			{ no: 1, name: 'figi', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 2, name: 'from', kind: 'message', T: () => Timestamp },
			{ no: 3, name: 'to', kind: 'message', T: () => Timestamp }
		]);
	}
	create(value?: PartialMessage<GetDividendsRequest>): GetDividendsRequest {
		const message = { figi: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<GetDividendsRequest>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDividendsRequest): GetDividendsRequest {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* string figi */ 1:
				message.figi = reader.string();
				break;
			case /* google.protobuf.Timestamp from */ 2:
				message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
				break;
			case /* google.protobuf.Timestamp to */ 3:
				message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: GetDividendsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* string figi = 1; */
		if (message.figi !== '')
			writer.tag(1, WireType.LengthDelimited).string(message.figi);
		/* google.protobuf.Timestamp from = 2; */
		if (message.from)
			Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp to = 3; */
		if (message.to)
			Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsRequest
 */
export const GetDividendsRequest = new GetDividendsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDividendsResponse$Type extends MessageType<GetDividendsResponse> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.GetDividendsResponse', [
			{ no: 1, name: 'dividends', kind: 'message', repeat: 1 /*RepeatType.PACKED*/, T: () => Dividend }
		]);
	}
	create(value?: PartialMessage<GetDividendsResponse>): GetDividendsResponse {
		const message = { dividends: [] };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<GetDividendsResponse>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDividendsResponse): GetDividendsResponse {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* repeated tinkoff.public.invest.api.contract.v1.Dividend dividends */ 1:
				message.dividends.push(Dividend.internalBinaryRead(reader, reader.uint32(), options));
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: GetDividendsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* repeated tinkoff.public.invest.api.contract.v1.Dividend dividends = 1; */
		for (let i = 0; i < message.dividends.length; i++)
			Dividend.internalBinaryWrite(message.dividends[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.GetDividendsResponse
 */
export const GetDividendsResponse = new GetDividendsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Dividend$Type extends MessageType<Dividend> {
	constructor() {
		super('tinkoff.public.invest.api.contract.v1.Dividend', [
			{ no: 1, name: 'dividend_net', kind: 'message', T: () => MoneyValue },
			{ no: 2, name: 'payment_date', kind: 'message', T: () => Timestamp },
			{ no: 3, name: 'declared_date', kind: 'message', T: () => Timestamp },
			{ no: 4, name: 'last_buy_date', kind: 'message', T: () => Timestamp },
			{ no: 5, name: 'dividend_type', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 6, name: 'record_date', kind: 'message', T: () => Timestamp },
			{ no: 7, name: 'regularity', kind: 'scalar', T: 9 /*ScalarType.STRING*/ },
			{ no: 8, name: 'close_price', kind: 'message', T: () => MoneyValue },
			{ no: 9, name: 'yield_value', kind: 'message', T: () => Quotation },
			{ no: 10, name: 'created_at', kind: 'message', T: () => Timestamp }
		]);
	}
	create(value?: PartialMessage<Dividend>): Dividend {
		const message = { dividendType: '', regularity: '' };
		globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
		if (value !== undefined)
			reflectionMergePartial<Dividend>(this, message, value);
		return message;
	}
	internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Dividend): Dividend {
		const message = target ?? this.create(), end = reader.pos + length;
		while (reader.pos < end) {
			const [fieldNo, wireType] = reader.tag();
			switch (fieldNo) {
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue dividend_net */ 1:
				message.dividendNet = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.dividendNet);
				break;
			case /* google.protobuf.Timestamp payment_date */ 2:
				message.paymentDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.paymentDate);
				break;
			case /* google.protobuf.Timestamp declared_date */ 3:
				message.declaredDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.declaredDate);
				break;
			case /* google.protobuf.Timestamp last_buy_date */ 4:
				message.lastBuyDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.lastBuyDate);
				break;
			case /* string dividend_type */ 5:
				message.dividendType = reader.string();
				break;
			case /* google.protobuf.Timestamp record_date */ 6:
				message.recordDate = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.recordDate);
				break;
			case /* string regularity */ 7:
				message.regularity = reader.string();
				break;
			case /* tinkoff.public.invest.api.contract.v1.MoneyValue close_price */ 8:
				message.closePrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.closePrice);
				break;
			case /* tinkoff.public.invest.api.contract.v1.Quotation yield_value */ 9:
				message.yieldValue = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.yieldValue);
				break;
			case /* google.protobuf.Timestamp created_at */ 10:
				message.createdAt = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.createdAt);
				break;
			default:
				const u = options.readUnknownField;
				if (u === 'throw')
					throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
				const d = reader.skip(wireType);
				if (u !== false)
					(u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
			}
		}
		return message;
	}
	internalBinaryWrite(message: Dividend, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
		/* tinkoff.public.invest.api.contract.v1.MoneyValue dividend_net = 1; */
		if (message.dividendNet)
			MoneyValue.internalBinaryWrite(message.dividendNet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp payment_date = 2; */
		if (message.paymentDate)
			Timestamp.internalBinaryWrite(message.paymentDate, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp declared_date = 3; */
		if (message.declaredDate)
			Timestamp.internalBinaryWrite(message.declaredDate, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp last_buy_date = 4; */
		if (message.lastBuyDate)
			Timestamp.internalBinaryWrite(message.lastBuyDate, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
		/* string dividend_type = 5; */
		if (message.dividendType !== '')
			writer.tag(5, WireType.LengthDelimited).string(message.dividendType);
		/* google.protobuf.Timestamp record_date = 6; */
		if (message.recordDate)
			Timestamp.internalBinaryWrite(message.recordDate, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
		/* string regularity = 7; */
		if (message.regularity !== '')
			writer.tag(7, WireType.LengthDelimited).string(message.regularity);
		/* tinkoff.public.invest.api.contract.v1.MoneyValue close_price = 8; */
		if (message.closePrice)
			MoneyValue.internalBinaryWrite(message.closePrice, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
		/* tinkoff.public.invest.api.contract.v1.Quotation yield_value = 9; */
		if (message.yieldValue)
			Quotation.internalBinaryWrite(message.yieldValue, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
		/* google.protobuf.Timestamp created_at = 10; */
		if (message.createdAt)
			Timestamp.internalBinaryWrite(message.createdAt, writer.tag(10, WireType.LengthDelimited).fork(), options).join();
		const u = options.writeUnknownFields;
		if (u !== false)
			(u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
		return writer;
	}
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Dividend
 */
export const Dividend = new Dividend$Type();
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.InstrumentsService
 */
export const InstrumentsService = new ServiceType('tinkoff.public.invest.api.contract.v1.InstrumentsService', [
	{ name: 'TradingSchedules', options: {}, I: TradingSchedulesRequest, O: TradingSchedulesResponse },
	{ name: 'BondBy', options: {}, I: InstrumentRequest, O: BondResponse },
	{ name: 'Bonds', options: {}, I: InstrumentsRequest, O: BondsResponse },
	{ name: 'CurrencyBy', options: {}, I: InstrumentRequest, O: CurrencyResponse },
	{ name: 'Currencies', options: {}, I: InstrumentsRequest, O: CurrenciesResponse },
	{ name: 'EtfBy', options: {}, I: InstrumentRequest, O: EtfResponse },
	{ name: 'Etfs', options: {}, I: InstrumentsRequest, O: EtfsResponse },
	{ name: 'FutureBy', options: {}, I: InstrumentRequest, O: FutureResponse },
	{ name: 'Futures', options: {}, I: InstrumentsRequest, O: FuturesResponse },
	{ name: 'ShareBy', options: {}, I: InstrumentRequest, O: ShareResponse },
	{ name: 'Shares', options: {}, I: InstrumentsRequest, O: SharesResponse },
	{ name: 'GetAccruedInterests', options: {}, I: GetAccruedInterestsRequest, O: GetAccruedInterestsResponse },
	{ name: 'GetFuturesMargin', options: {}, I: GetFuturesMarginRequest, O: GetFuturesMarginResponse },
	{ name: 'GetInstrumentBy', options: {}, I: InstrumentRequest, O: InstrumentResponse },
	{ name: 'GetDividends', options: {}, I: GetDividendsRequest, O: GetDividendsResponse }
]);
