// @generated by protobuf-ts 2.2.2 with parameter generate_dependencies
// @generated from protobuf file "operations.proto" (package "tinkoff.public.invest.api.contract.v1", syntax proto3)
// tslint:disable
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MESSAGE_TYPE } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { Quotation } from "./common";
import { MoneyValue } from "./common";
import { Timestamp } from "./google/protobuf/timestamp";
/**
 * Запрос получения списка операций по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OperationsRequest
 */
export interface OperationsRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта клиента
    /**
     * @generated from protobuf field: google.protobuf.Timestamp from = 2;
     */
    from?: Timestamp; // Начало периода (по UTC)
    /**
     * @generated from protobuf field: google.protobuf.Timestamp to = 3;
     */
    to?: Timestamp; // Окончание периода (по UTC)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationState state = 4;
     */
    state: OperationState; // Статус запрашиваемых операций
    /**
     * @generated from protobuf field: string figi = 5;
     */
    figi: string; // Figi-идентификатор инструмента для фильтрации
}
/**
 * Список операций.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.OperationsResponse
 */
export interface OperationsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.Operation operations = 1;
     */
    operations: Operation[]; // Массив операций
}
/**
 * Данные по операции.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.Operation
 */
export interface Operation {
    /**
     * @generated from protobuf field: string id = 1;
     */
    id: string; // Идентификатор операции
    /**
     * @generated from protobuf field: string parent_operation_id = 2;
     */
    parentOperationId: string; // Идентификатор родительской операции
    /**
     * @generated from protobuf field: string currency = 3;
     */
    currency: string; // Валюта операции
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue payment = 4;
     */
    payment?: MoneyValue; // Сумма операции
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue price = 5;
     */
    price?: MoneyValue; // Цена операции
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationState state = 6;
     */
    state: OperationState; // Статус операции
    /**
     * @generated from protobuf field: int64 quantity = 7;
     */
    quantity: bigint; // Количество лотов инструмента
    /**
     * @generated from protobuf field: int64 quantity_rest = 8;
     */
    quantityRest: bigint; // Неисполненный остаток по сделке
    /**
     * @generated from protobuf field: string figi = 9;
     */
    figi: string; // Figi-идентификатор инструмента, связанного с операцией
    /**
     * @generated from protobuf field: string instrument_type = 10;
     */
    instrumentType: string; // Тип инструмента. Возможные значения: </br>**bond** — облигация; </br>**share** — акция; </br>**currency** — валюта; </br>**etf** — фонд; </br>**futures** — фьючерс.
    /**
     * @generated from protobuf field: google.protobuf.Timestamp date = 11;
     */
    date?: Timestamp; // Дата и время операции в формате часовом поясе UTC
    /**
     * @generated from protobuf field: string type = 12;
     */
    type: string; // Текстовое описание типа операции
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.OperationType operation_type = 13;
     */
    operationType: OperationType; // Тип операции
}
/**
 * Запрос получения текущего портфеля по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioRequest
 */
export interface PortfolioRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта пользователя
}
/**
 * Текущий портфель по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioResponse
 */
export interface PortfolioResponse {
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_shares = 1;
     */
    totalAmountShares?: MoneyValue; // Общая стоимость акций в портфеле в рублях
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_bonds = 2;
     */
    totalAmountBonds?: MoneyValue; // Общая стоимость облигаций в портфеле в рублях
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_etf = 3;
     */
    totalAmountEtf?: MoneyValue; // Общая стоимость фондов в портфеле в рублях
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_currencies = 4;
     */
    totalAmountCurrencies?: MoneyValue; // Общая стоимость валют в портфеле в рублях
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_futures = 5;
     */
    totalAmountFutures?: MoneyValue; // Общая стоимость фьючерсов в портфеле в рублях
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 6;
     */
    expectedYield?: Quotation; // Текущая доходность портфеля
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PortfolioPosition positions = 7;
     */
    positions: PortfolioPosition[]; // Список позиций портфеля
}
/**
 * Запрос позиций портфеля по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsRequest
 */
export interface PositionsRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта пользователя
}
/**
 * Список позиций по счёту.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsResponse
 */
export interface PositionsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue money = 1;
     */
    money: MoneyValue[]; // Массив валютных позиций портфеля
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked = 2;
     */
    blocked: MoneyValue[]; // Массив заблокированных валютных позиций портфеля
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities = 3;
     */
    securities: PositionsSecurities[]; // Список ценно-бумажных позиций портфеля
    /**
     * @generated from protobuf field: bool limits_loading_in_progress = 4;
     */
    limitsLoadingInProgress: boolean; // Признак идущей в данный момент выгрузки лимитов
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures = 5;
     */
    futures: PositionsFutures[]; // Список фьючерсов портфеля
}
/**
 * Запрос доступного для вывода остатка.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.WithdrawLimitsRequest
 */
export interface WithdrawLimitsRequest {
    /**
     * @generated from protobuf field: string account_id = 1;
     */
    accountId: string; // Идентификатор счёта пользователя
}
/**
 * Доступный для вывода остаток.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.WithdrawLimitsResponse
 */
export interface WithdrawLimitsResponse {
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue money = 1;
     */
    money: MoneyValue[]; // Массив валютных позиций портфеля
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked = 2;
     */
    blocked: MoneyValue[]; // Массив заблокированных валютных позиций портфеля
    /**
     * @generated from protobuf field: repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked_guarantee = 3;
     */
    blockedGuarantee: MoneyValue[]; // Заблокировано под гарантийное обеспечение фьючерсов
}
/**
 * Позиции портфеля.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PortfolioPosition
 */
export interface PortfolioPosition {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатора инструмента
    /**
     * @generated from protobuf field: string instrument_type = 2;
     */
    instrumentType: string; // Тип инструмента
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation quantity = 3;
     */
    quantity?: Quotation; // Количество инструмента в портфеле в штуках
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price = 4;
     */
    averagePositionPrice?: MoneyValue; // Средняя цена лота в позиции
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 5;
     */
    expectedYield?: Quotation; // Текущая рассчитанная доходность
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue current_nkd = 6;
     */
    currentNkd?: MoneyValue; // Текущий НКД
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.Quotation average_position_price_pt = 7;
     */
    averagePositionPricePt?: Quotation; // Средняя цена лота в позиции в пунктах (для фьючерсов)
    /**
     * @generated from protobuf field: tinkoff.public.invest.api.contract.v1.MoneyValue current_price = 8;
     */
    currentPrice?: MoneyValue; // Текущая цена инструмента
}
/**
 * Баланс позиции ценной бумаги.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsSecurities
 */
export interface PositionsSecurities {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор бумаги
    /**
     * @generated from protobuf field: int64 blocked = 2;
     */
    blocked: bigint; // Заблокировано
    /**
     * @generated from protobuf field: int64 balance = 3;
     */
    balance: bigint; // Текущий баланс
}
/**
 * Баланс фьючерса.
 *
 * @generated from protobuf message tinkoff.public.invest.api.contract.v1.PositionsFutures
 */
export interface PositionsFutures {
    /**
     * @generated from protobuf field: string figi = 1;
     */
    figi: string; // Figi-идентификатор фьючерса
    /**
     * @generated from protobuf field: int64 blocked = 2;
     */
    blocked: bigint; // Заблокировано
    /**
     * @generated from protobuf field: int64 balance = 3;
     */
    balance: bigint; // Текущий баланс
}
/**
 * Статус запрашиваемых операций
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OperationState
 */
export enum OperationState {
    /**
     * Статус операции не определён
     *
     * @generated from protobuf enum value: OPERATION_STATE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Исполнена
     *
     * @generated from protobuf enum value: OPERATION_STATE_EXECUTED = 1;
     */
    EXECUTED = 1,
    /**
     * Отменена
     *
     * @generated from protobuf enum value: OPERATION_STATE_CANCELED = 2;
     */
    CANCELED = 2
}
/**
 * Тип операции
 *
 * @generated from protobuf enum tinkoff.public.invest.api.contract.v1.OperationType
 */
export enum OperationType {
    /**
     * Тип операции не определён
     *
     * @generated from protobuf enum value: OPERATION_TYPE_UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * Завод денежных средств
     *
     * @generated from protobuf enum value: OPERATION_TYPE_INPUT = 1;
     */
    INPUT = 1,
    /**
     * Удержание налога по купонам
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BOND_TAX = 2;
     */
    BOND_TAX = 2,
    /**
     * Вывод ЦБ
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUTPUT_SECURITIES = 3;
     */
    OUTPUT_SECURITIES = 3,
    /**
     * Доход по сделке РЕПО овернайт
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OVERNIGHT = 4;
     */
    OVERNIGHT = 4,
    /**
     * Удержание налога
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX = 5;
     */
    TAX = 5,
    /**
     * Полное погашение облигаций
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BOND_REPAYMENT_FULL = 6;
     */
    BOND_REPAYMENT_FULL = 6,
    /**
     * Продажа ЦБ с карты
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SELL_CARD = 7;
     */
    SELL_CARD = 7,
    /**
     * Удержание налога по дивидендам
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIVIDEND_TAX = 8;
     */
    DIVIDEND_TAX = 8,
    /**
     * Вывод денежных средств
     *
     * @generated from protobuf enum value: OPERATION_TYPE_OUTPUT = 9;
     */
    OUTPUT = 9,
    /**
     * Частичное погашение облигаций
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BOND_REPAYMENT = 10;
     */
    BOND_REPAYMENT = 10,
    /**
     * Корректировка налога
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_CORRECTION = 11;
     */
    TAX_CORRECTION = 11,
    /**
     * Удержание комиссии за обслуживание брокерского счёта
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SERVICE_FEE = 12;
     */
    SERVICE_FEE = 12,
    /**
     * Удержание налога за материальную выгоду
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BENEFIT_TAX = 13;
     */
    BENEFIT_TAX = 13,
    /**
     * Удержание комиссии за непокрытую позицию
     *
     * @generated from protobuf enum value: OPERATION_TYPE_MARGIN_FEE = 14;
     */
    MARGIN_FEE = 14,
    /**
     * Покупка ЦБ
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BUY = 15;
     */
    BUY = 15,
    /**
     * Покупка ЦБ с карты
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BUY_CARD = 16;
     */
    BUY_CARD = 16,
    /**
     * Завод ЦБ
     *
     * @generated from protobuf enum value: OPERATION_TYPE_INPUT_SECURITIES = 17;
     */
    INPUT_SECURITIES = 17,
    /**
     * Продажа в результате Margin-call
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SELL_MARGIN = 18;
     */
    SELL_MARGIN = 18,
    /**
     * Удержание комиссии за операцию
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BROKER_FEE = 19;
     */
    BROKER_FEE = 19,
    /**
     * Покупка в результате Margin-call
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BUY_MARGIN = 20;
     */
    BUY_MARGIN = 20,
    /**
     * Выплата дивидендов
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIVIDEND = 21;
     */
    DIVIDEND = 21,
    /**
     * Продажа ЦБ
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SELL = 22;
     */
    SELL = 22,
    /**
     * Выплата купонов
     *
     * @generated from protobuf enum value: OPERATION_TYPE_COUPON = 23;
     */
    COUPON = 23,
    /**
     * Удержание комиссии SuccessFee
     *
     * @generated from protobuf enum value: OPERATION_TYPE_SUCCESS_FEE = 24;
     */
    SUCCESS_FEE = 24,
    /**
     * Передача дивидендного дохода
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIVIDEND_TRANSFER = 25;
     */
    DIVIDEND_TRANSFER = 25,
    /**
     * Зачисление вариационной маржи
     *
     * @generated from protobuf enum value: OPERATION_TYPE_ACCRUING_VARMARGIN = 26;
     */
    ACCRUING_VARMARGIN = 26,
    /**
     * Списание вариационной маржи
     *
     * @generated from protobuf enum value: OPERATION_TYPE_WRITING_OFF_VARMARGIN = 27;
     */
    WRITING_OFF_VARMARGIN = 27,
    /**
     * Покупка в рамках экспирации фьючерсного контракта
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DELIVERY_BUY = 28;
     */
    DELIVERY_BUY = 28,
    /**
     * Продажа в рамках экспирации фьючерсного контракта
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DELIVERY_SELL = 29;
     */
    DELIVERY_SELL = 29,
    /**
     * Комиссия за управление по счёту автоследования
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TRACK_MFEE = 30;
     */
    TRACK_MFEE = 30,
    /**
     * Комиссия за результат по счёту автоследования
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TRACK_PFEE = 31;
     */
    TRACK_PFEE = 31,
    /**
     * Удержание налога по ставке 15%
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_PROGRESSIVE = 32;
     */
    TAX_PROGRESSIVE = 32,
    /**
     * Удержание налога по купонам по ставке 15%
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BOND_TAX_PROGRESSIVE = 33;
     */
    BOND_TAX_PROGRESSIVE = 33,
    /**
     * Удержание налога по дивидендам по ставке 15%
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIVIDEND_TAX_PROGRESSIVE = 34;
     */
    DIVIDEND_TAX_PROGRESSIVE = 34,
    /**
     * Удержание налога за материальную выгоду по ставке 15%
     *
     * @generated from protobuf enum value: OPERATION_TYPE_BENEFIT_TAX_PROGRESSIVE = 35;
     */
    BENEFIT_TAX_PROGRESSIVE = 35,
    /**
     * Корректировка налога по ставке 15%
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_CORRECTION_PROGRESSIVE = 36;
     */
    TAX_CORRECTION_PROGRESSIVE = 36,
    /**
     * Удержание налога за возмещение по сделкам РЕПО по ставке 15%
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_PROGRESSIVE = 37;
     */
    TAX_REPO_PROGRESSIVE = 37,
    /**
     * Удержание налога за возмещение по сделкам РЕПО
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO = 38;
     */
    TAX_REPO = 38,
    /**
     * Удержание налога по сделкам РЕПО
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_HOLD = 39;
     */
    TAX_REPO_HOLD = 39,
    /**
     * Возврат налога по сделкам РЕПО
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_REFUND = 40;
     */
    TAX_REPO_REFUND = 40,
    /**
     * Удержание налога по сделкам РЕПО по ставке 15%
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_HOLD_PROGRESSIVE = 41;
     */
    TAX_REPO_HOLD_PROGRESSIVE = 41,
    /**
     * Возврат налога по сделкам РЕПО по ставке 15%
     *
     * @generated from protobuf enum value: OPERATION_TYPE_TAX_REPO_REFUND_PROGRESSIVE = 42;
     */
    TAX_REPO_REFUND_PROGRESSIVE = 42,
    /**
     * Выплата дивидендов на карту
     *
     * @generated from protobuf enum value: OPERATION_TYPE_DIV_EXT = 43;
     */
    DIV_EXT = 43
}
// @generated message type with reflection information, may provide speed optimized methods
class OperationsRequest$Type extends MessageType<OperationsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OperationsRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "from", kind: "message", T: () => Timestamp },
            { no: 3, name: "to", kind: "message", T: () => Timestamp },
            { no: 4, name: "state", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationState", OperationState, "OPERATION_STATE_"] },
            { no: 5, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<OperationsRequest>): OperationsRequest {
        const message = { accountId: "", state: 0, figi: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationsRequest): OperationsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                case /* google.protobuf.Timestamp from */ 2:
                    message.from = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.from);
                    break;
                case /* google.protobuf.Timestamp to */ 3:
                    message.to = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.to);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationState state */ 4:
                    message.state = reader.int32();
                    break;
                case /* string figi */ 5:
                    message.figi = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        /* google.protobuf.Timestamp from = 2; */
        if (message.from)
            Timestamp.internalBinaryWrite(message.from, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* google.protobuf.Timestamp to = 3; */
        if (message.to)
            Timestamp.internalBinaryWrite(message.to, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OperationState state = 4; */
        if (message.state !== 0)
            writer.tag(4, WireType.Varint).int32(message.state);
        /* string figi = 5; */
        if (message.figi !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.figi);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OperationsRequest
 */
export const OperationsRequest = new OperationsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class OperationsResponse$Type extends MessageType<OperationsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.OperationsResponse", [
            { no: 1, name: "operations", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Operation }
        ]);
    }
    create(value?: PartialMessage<OperationsResponse>): OperationsResponse {
        const message = { operations: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<OperationsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OperationsResponse): OperationsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.Operation operations */ 1:
                    message.operations.push(Operation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OperationsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.Operation operations = 1; */
        for (let i = 0; i < message.operations.length; i++)
            Operation.internalBinaryWrite(message.operations[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.OperationsResponse
 */
export const OperationsResponse = new OperationsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Operation$Type extends MessageType<Operation> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.Operation", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "parent_operation_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "currency", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "payment", kind: "message", T: () => MoneyValue },
            { no: 5, name: "price", kind: "message", T: () => MoneyValue },
            { no: 6, name: "state", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationState", OperationState, "OPERATION_STATE_"] },
            { no: 7, name: "quantity", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 8, name: "quantity_rest", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 9, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 10, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 11, name: "date", kind: "message", T: () => Timestamp },
            { no: 12, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 13, name: "operation_type", kind: "enum", T: () => ["tinkoff.public.invest.api.contract.v1.OperationType", OperationType, "OPERATION_TYPE_"] }
        ]);
    }
    create(value?: PartialMessage<Operation>): Operation {
        const message = { id: "", parentOperationId: "", currency: "", state: 0, quantity: 0n, quantityRest: 0n, figi: "", instrumentType: "", type: "", operationType: 0 };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<Operation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Operation): Operation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string parent_operation_id */ 2:
                    message.parentOperationId = reader.string();
                    break;
                case /* string currency */ 3:
                    message.currency = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue payment */ 4:
                    message.payment = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.payment);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue price */ 5:
                    message.price = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.price);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationState state */ 6:
                    message.state = reader.int32();
                    break;
                case /* int64 quantity */ 7:
                    message.quantity = reader.int64().toBigInt();
                    break;
                case /* int64 quantity_rest */ 8:
                    message.quantityRest = reader.int64().toBigInt();
                    break;
                case /* string figi */ 9:
                    message.figi = reader.string();
                    break;
                case /* string instrument_type */ 10:
                    message.instrumentType = reader.string();
                    break;
                case /* google.protobuf.Timestamp date */ 11:
                    message.date = Timestamp.internalBinaryRead(reader, reader.uint32(), options, message.date);
                    break;
                case /* string type */ 12:
                    message.type = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.OperationType operation_type */ 13:
                    message.operationType = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Operation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string parent_operation_id = 2; */
        if (message.parentOperationId !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.parentOperationId);
        /* string currency = 3; */
        if (message.currency !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.currency);
        /* tinkoff.public.invest.api.contract.v1.MoneyValue payment = 4; */
        if (message.payment)
            MoneyValue.internalBinaryWrite(message.payment, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue price = 5; */
        if (message.price)
            MoneyValue.internalBinaryWrite(message.price, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.OperationState state = 6; */
        if (message.state !== 0)
            writer.tag(6, WireType.Varint).int32(message.state);
        /* int64 quantity = 7; */
        if (message.quantity !== 0n)
            writer.tag(7, WireType.Varint).int64(message.quantity);
        /* int64 quantity_rest = 8; */
        if (message.quantityRest !== 0n)
            writer.tag(8, WireType.Varint).int64(message.quantityRest);
        /* string figi = 9; */
        if (message.figi !== "")
            writer.tag(9, WireType.LengthDelimited).string(message.figi);
        /* string instrument_type = 10; */
        if (message.instrumentType !== "")
            writer.tag(10, WireType.LengthDelimited).string(message.instrumentType);
        /* google.protobuf.Timestamp date = 11; */
        if (message.date)
            Timestamp.internalBinaryWrite(message.date, writer.tag(11, WireType.LengthDelimited).fork(), options).join();
        /* string type = 12; */
        if (message.type !== "")
            writer.tag(12, WireType.LengthDelimited).string(message.type);
        /* tinkoff.public.invest.api.contract.v1.OperationType operation_type = 13; */
        if (message.operationType !== 0)
            writer.tag(13, WireType.Varint).int32(message.operationType);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.Operation
 */
export const Operation = new Operation$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioRequest$Type extends MessageType<PortfolioRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PortfolioRequest>): PortfolioRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioRequest): PortfolioRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioRequest
 */
export const PortfolioRequest = new PortfolioRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioResponse$Type extends MessageType<PortfolioResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioResponse", [
            { no: 1, name: "total_amount_shares", kind: "message", T: () => MoneyValue },
            { no: 2, name: "total_amount_bonds", kind: "message", T: () => MoneyValue },
            { no: 3, name: "total_amount_etf", kind: "message", T: () => MoneyValue },
            { no: 4, name: "total_amount_currencies", kind: "message", T: () => MoneyValue },
            { no: 5, name: "total_amount_futures", kind: "message", T: () => MoneyValue },
            { no: 6, name: "expected_yield", kind: "message", T: () => Quotation },
            { no: 7, name: "positions", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PortfolioPosition }
        ]);
    }
    create(value?: PartialMessage<PortfolioResponse>): PortfolioResponse {
        const message = { positions: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioResponse): PortfolioResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_shares */ 1:
                    message.totalAmountShares = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountShares);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_bonds */ 2:
                    message.totalAmountBonds = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountBonds);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_etf */ 3:
                    message.totalAmountEtf = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountEtf);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_currencies */ 4:
                    message.totalAmountCurrencies = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountCurrencies);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_futures */ 5:
                    message.totalAmountFutures = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.totalAmountFutures);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield */ 6:
                    message.expectedYield = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.expectedYield);
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PortfolioPosition positions */ 7:
                    message.positions.push(PortfolioPosition.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_shares = 1; */
        if (message.totalAmountShares)
            MoneyValue.internalBinaryWrite(message.totalAmountShares, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_bonds = 2; */
        if (message.totalAmountBonds)
            MoneyValue.internalBinaryWrite(message.totalAmountBonds, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_etf = 3; */
        if (message.totalAmountEtf)
            MoneyValue.internalBinaryWrite(message.totalAmountEtf, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_currencies = 4; */
        if (message.totalAmountCurrencies)
            MoneyValue.internalBinaryWrite(message.totalAmountCurrencies, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue total_amount_futures = 5; */
        if (message.totalAmountFutures)
            MoneyValue.internalBinaryWrite(message.totalAmountFutures, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 6; */
        if (message.expectedYield)
            Quotation.internalBinaryWrite(message.expectedYield, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.PortfolioPosition positions = 7; */
        for (let i = 0; i < message.positions.length; i++)
            PortfolioPosition.internalBinaryWrite(message.positions[i], writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioResponse
 */
export const PortfolioResponse = new PortfolioResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsRequest$Type extends MessageType<PositionsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsRequest>): PositionsRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsRequest): PositionsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsRequest
 */
export const PositionsRequest = new PositionsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsResponse$Type extends MessageType<PositionsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsResponse", [
            { no: 1, name: "money", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue },
            { no: 2, name: "blocked", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue },
            { no: 3, name: "securities", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsSecurities },
            { no: 4, name: "limits_loading_in_progress", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 5, name: "futures", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => PositionsFutures }
        ]);
    }
    create(value?: PartialMessage<PositionsResponse>): PositionsResponse {
        const message = { money: [], blocked: [], securities: [], limitsLoadingInProgress: false, futures: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsResponse): PositionsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue money */ 1:
                    message.money.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked */ 2:
                    message.blocked.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities */ 3:
                    message.securities.push(PositionsSecurities.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* bool limits_loading_in_progress */ 4:
                    message.limitsLoadingInProgress = reader.bool();
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures */ 5:
                    message.futures.push(PositionsFutures.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue money = 1; */
        for (let i = 0; i < message.money.length; i++)
            MoneyValue.internalBinaryWrite(message.money[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked = 2; */
        for (let i = 0; i < message.blocked.length; i++)
            MoneyValue.internalBinaryWrite(message.blocked[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsSecurities securities = 3; */
        for (let i = 0; i < message.securities.length; i++)
            PositionsSecurities.internalBinaryWrite(message.securities[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* bool limits_loading_in_progress = 4; */
        if (message.limitsLoadingInProgress !== false)
            writer.tag(4, WireType.Varint).bool(message.limitsLoadingInProgress);
        /* repeated tinkoff.public.invest.api.contract.v1.PositionsFutures futures = 5; */
        for (let i = 0; i < message.futures.length; i++)
            PositionsFutures.internalBinaryWrite(message.futures[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsResponse
 */
export const PositionsResponse = new PositionsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawLimitsRequest$Type extends MessageType<WithdrawLimitsRequest> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.WithdrawLimitsRequest", [
            { no: 1, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<WithdrawLimitsRequest>): WithdrawLimitsRequest {
        const message = { accountId: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawLimitsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawLimitsRequest): WithdrawLimitsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string account_id */ 1:
                    message.accountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawLimitsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string account_id = 1; */
        if (message.accountId !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.WithdrawLimitsRequest
 */
export const WithdrawLimitsRequest = new WithdrawLimitsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WithdrawLimitsResponse$Type extends MessageType<WithdrawLimitsResponse> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.WithdrawLimitsResponse", [
            { no: 1, name: "money", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue },
            { no: 2, name: "blocked", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue },
            { no: 3, name: "blocked_guarantee", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => MoneyValue }
        ]);
    }
    create(value?: PartialMessage<WithdrawLimitsResponse>): WithdrawLimitsResponse {
        const message = { money: [], blocked: [], blockedGuarantee: [] };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<WithdrawLimitsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WithdrawLimitsResponse): WithdrawLimitsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue money */ 1:
                    message.money.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked */ 2:
                    message.blocked.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked_guarantee */ 3:
                    message.blockedGuarantee.push(MoneyValue.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WithdrawLimitsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue money = 1; */
        for (let i = 0; i < message.money.length; i++)
            MoneyValue.internalBinaryWrite(message.money[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked = 2; */
        for (let i = 0; i < message.blocked.length; i++)
            MoneyValue.internalBinaryWrite(message.blocked[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated tinkoff.public.invest.api.contract.v1.MoneyValue blocked_guarantee = 3; */
        for (let i = 0; i < message.blockedGuarantee.length; i++)
            MoneyValue.internalBinaryWrite(message.blockedGuarantee[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.WithdrawLimitsResponse
 */
export const WithdrawLimitsResponse = new WithdrawLimitsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PortfolioPosition$Type extends MessageType<PortfolioPosition> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PortfolioPosition", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "instrument_type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "quantity", kind: "message", T: () => Quotation },
            { no: 4, name: "average_position_price", kind: "message", T: () => MoneyValue },
            { no: 5, name: "expected_yield", kind: "message", T: () => Quotation },
            { no: 6, name: "current_nkd", kind: "message", T: () => MoneyValue },
            { no: 7, name: "average_position_price_pt", kind: "message", T: () => Quotation },
            { no: 8, name: "current_price", kind: "message", T: () => MoneyValue }
        ]);
    }
    create(value?: PartialMessage<PortfolioPosition>): PortfolioPosition {
        const message = { figi: "", instrumentType: "" };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PortfolioPosition>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PortfolioPosition): PortfolioPosition {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* string instrument_type */ 2:
                    message.instrumentType = reader.string();
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation quantity */ 3:
                    message.quantity = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.quantity);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price */ 4:
                    message.averagePositionPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.averagePositionPrice);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield */ 5:
                    message.expectedYield = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.expectedYield);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue current_nkd */ 6:
                    message.currentNkd = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.currentNkd);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.Quotation average_position_price_pt */ 7:
                    message.averagePositionPricePt = Quotation.internalBinaryRead(reader, reader.uint32(), options, message.averagePositionPricePt);
                    break;
                case /* tinkoff.public.invest.api.contract.v1.MoneyValue current_price */ 8:
                    message.currentPrice = MoneyValue.internalBinaryRead(reader, reader.uint32(), options, message.currentPrice);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PortfolioPosition, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* string instrument_type = 2; */
        if (message.instrumentType !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.instrumentType);
        /* tinkoff.public.invest.api.contract.v1.Quotation quantity = 3; */
        if (message.quantity)
            Quotation.internalBinaryWrite(message.quantity, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue average_position_price = 4; */
        if (message.averagePositionPrice)
            MoneyValue.internalBinaryWrite(message.averagePositionPrice, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation expected_yield = 5; */
        if (message.expectedYield)
            Quotation.internalBinaryWrite(message.expectedYield, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue current_nkd = 6; */
        if (message.currentNkd)
            MoneyValue.internalBinaryWrite(message.currentNkd, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.Quotation average_position_price_pt = 7; */
        if (message.averagePositionPricePt)
            Quotation.internalBinaryWrite(message.averagePositionPricePt, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* tinkoff.public.invest.api.contract.v1.MoneyValue current_price = 8; */
        if (message.currentPrice)
            MoneyValue.internalBinaryWrite(message.currentPrice, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PortfolioPosition
 */
export const PortfolioPosition = new PortfolioPosition$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsSecurities$Type extends MessageType<PositionsSecurities> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsSecurities", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blocked", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsSecurities>): PositionsSecurities {
        const message = { figi: "", blocked: 0n, balance: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsSecurities>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsSecurities): PositionsSecurities {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int64 blocked */ 2:
                    message.blocked = reader.int64().toBigInt();
                    break;
                case /* int64 balance */ 3:
                    message.balance = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsSecurities, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int64 blocked = 2; */
        if (message.blocked !== 0n)
            writer.tag(2, WireType.Varint).int64(message.blocked);
        /* int64 balance = 3; */
        if (message.balance !== 0n)
            writer.tag(3, WireType.Varint).int64(message.balance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsSecurities
 */
export const PositionsSecurities = new PositionsSecurities$Type();
// @generated message type with reflection information, may provide speed optimized methods
class PositionsFutures$Type extends MessageType<PositionsFutures> {
    constructor() {
        super("tinkoff.public.invest.api.contract.v1.PositionsFutures", [
            { no: 1, name: "figi", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "blocked", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 3, name: "balance", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<PositionsFutures>): PositionsFutures {
        const message = { figi: "", blocked: 0n, balance: 0n };
        globalThis.Object.defineProperty(message, MESSAGE_TYPE, { enumerable: false, value: this });
        if (value !== undefined)
            reflectionMergePartial<PositionsFutures>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PositionsFutures): PositionsFutures {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string figi */ 1:
                    message.figi = reader.string();
                    break;
                case /* int64 blocked */ 2:
                    message.blocked = reader.int64().toBigInt();
                    break;
                case /* int64 balance */ 3:
                    message.balance = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PositionsFutures, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string figi = 1; */
        if (message.figi !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.figi);
        /* int64 blocked = 2; */
        if (message.blocked !== 0n)
            writer.tag(2, WireType.Varint).int64(message.blocked);
        /* int64 balance = 3; */
        if (message.balance !== 0n)
            writer.tag(3, WireType.Varint).int64(message.balance);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message tinkoff.public.invest.api.contract.v1.PositionsFutures
 */
export const PositionsFutures = new PositionsFutures$Type();
/**
 * @generated ServiceType for protobuf service tinkoff.public.invest.api.contract.v1.OperationsService
 */
export const OperationsService = new ServiceType("tinkoff.public.invest.api.contract.v1.OperationsService", [
    { name: "GetOperations", options: {}, I: OperationsRequest, O: OperationsResponse },
    { name: "GetPortfolio", options: {}, I: PortfolioRequest, O: PortfolioResponse },
    { name: "GetPositions", options: {}, I: PositionsRequest, O: PositionsResponse },
    { name: "GetWithdrawLimits", options: {}, I: WithdrawLimitsRequest, O: WithdrawLimitsResponse }
]);
